## Object Oriented Programming(OOP)

### OOP가 나오게 된 배경

정의한 기능의 흐름에 따라 **순서대로 동작을 추가하며 프로그램을 완성**하는 방식이다. 

간단한 프로그램의 경우, 이렇게 코드를 짜게 되면 **흐름이 눈으로 보이기 때문에 매우 직관적**일 것이다. 그러나, 조금이라도 프로그램의 규모가 커지게 되면 곤란해진다. 만일 A → B → C 라는 동작을 구현하다가, C 에서 A 로 돌아가야할 상황이라면 `goto` 를 활용해야 한다.

`goto` 문을 무분별하게 활용하게 되면, 그야말로 **스파게티 그 자체가 완성**된다. 쭉 나열된 코드 속에서 위로 갔다가 아래로 갔다가 난리도 아니게 된다. 그렇게 되면 **동작이 직관적이지 못하게 되고**, 유일한 장점이 사라지는 셈이다.

그래서 등장한 것이 **절차적, 구조적** 프로그래밍이다.

<br>

### 절차적 (구조적) 프로그래밍

절차적 프로그래밍에서 **'절차'는 함수를 의미**한다. 따라서 절차적 프로그래밍이란, **반복되는 동작을 함수 및 프로시저(리턴값이 없는 함수)형태로 모듈화하여 사용**하는 방식이다.

-> 프로시저 자체가 추상적

예를들어,

도서관의 도서 관리 프로그램을 개발한다고 하자.

- **'책'이라는 자료형을 구현해야 함**
- **책에 대한 함수를 구현해야 함**

그러나, 구조적 프로그래밍에서는 이 둘을 따로 생각할 수 밖에 없다. **책은 책이고 책에 관한 함수는 따로 있기** 때문에, 같은 소스코드 파일 내에 있더라도 이 **둘의 연관 여부는 단 번에 알아차리기 어렵다**. 즉, **논리적으로 묶여있을 수 없는 구조이기 때문에 동작이 추상적**인 것이다.

따라서, 이를 묶기 위한 패러다임으로 '객체지향 프로그래밍' 이 등장하게 된 것이다.



### 객체 지향 프로그래밍?

 [컴퓨터 프로그래밍](https://ko.wikipedia.org/wiki/컴퓨터_프로그래밍)의 [패러다임](https://ko.wikipedia.org/wiki/패러다임) 중 하나. 어떤 개념에 대한 자료형과 함수를 **'객체' 형태로 함께 묶어서 관리**하기 위해 **객체지향 프로그래밍 패러다임**

`point!` **객체 내부에 자료형 필드와 함수가 함께 존재**하는 것이다. 가능한 모든 물리적, 논리적 요소를 객체로 만드는 것이 객체지향 프로그래밍이다.

 [컴퓨터 프로그램](https://ko.wikipedia.org/wiki/컴퓨터_프로그램)을 [명령어](https://ko.wikipedia.org/wiki/명령어_(컴퓨팅))의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "[객체](https://ko.wikipedia.org/wiki/객체_(컴퓨터_과학))"들의 모임으로 파악하고자 하는 것 - 각각의 객체는 [메시지](https://ko.wikipedia.org/wiki/메시지)를 주고받고, [데이터](https://ko.wikipedia.org/wiki/데이터)를 처리할 수 있다.



##### OOP 로 코드를 작성하면?

- 이미 작성한 코드에 대한 재사용성이 높다. 자주 사용되는 로직을 라이브러리로 만들어두면 계속해서 사용할 수 있으며 그 신뢰성을 확보 할 수 있다.
- 라이브러리를 각종 예외상황에 맞게 잘 만들어두면 개발자가 사소한 실수를 하더라도 그 에러를 컴파일 단계에서 잡아낼 수 있으므로 버그 발생이 줄어든다.
- 객체 단위로 코드가 나눠져 작성되기 때문에 디버깅이 쉽고 유지보수에 용이하다.
- 데이터 모델링을 할 때 객체와 매핑하는 것이 수월하기 때문에 요구사항을 보다 명확하게 파악하여 프로그래밍 할 수 있다.
- 프로그램을 유연하고 변경이 쉽게 만들기 때문에 대규모 [소프트웨어 개발](https://ko.wikipedia.org/wiki/소프트웨어_개발)에 많이 사용된다. 
- 또한 프로그래밍을 더 배우기 쉽게 하고 소프트웨어 개발과 보수를 간편하게 하며, 보다 직관적인 [코드](https://ko.wikipedia.org/wiki/소스_코드) 분석을 가능하게 하는 장점이 있다. 

그러나, 지나친 프로그램의 객체화 경향은 실제 세계의 모습을 그대로 반영하지 못한다는 비판을 받기도 한다.

<br>

### 객체 지향적 설계 원칙

1. SRP(Single Responsibility Principle) : `단일 책임 원칙`
   클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.

   예를 들어, A라는 로직이 있다면 어떤 클래스는 A에 관한 클래스여야하고 이를 수정해도 A와 관련된 수정이어야 한다.

2. OCP(Open-Closed Principle) : `개방-폐쇄 원칙`
   유지 보수 상황이 생긴다면 코드를 쉽게 확장할 수 있도록 하고 수정할때는 닫혀 있어야 하는 원칙.

   기존의 코드는 잘 변경하지 않으면서도 확장은 쉽게 할 수 있어야 한다.

3. LSP(Liskov Substitution Principle) : `리스코프 치환 원칙`
   상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.

4. ISP(Interface Segregation Principle) : `인터페이스 분리 원칙`
   하나의 일반적인 인터페이스보다 구체적인 여러개의 인터페이스를 만들어야 하는 원칙

5. DIP(Dependency Inversion Principle) : `의존 역전 원칙`
   고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

   예를 들어, 타이어를 갈아끼울 수 있는 틀을 만들어 놓은 뒤 다양한 타이어를 교체할 수 있어야 한다.

   즉 상위 계층은 하위 계층에 변화에 대한 구현으로 부터 독립적이여야 한다.

<br>

### 기본 구성 요소

- `클래스(Class)` - 같은 종류(또는 문제 해결을 위한)의 집단에 속하는 속성(attribute)과 행위(behavior)를 정의한 것으로 객체지향 프로그램의 기본적인 사용자 정의 데이터형(user defined data type)이라고 할 수 있다. 클래스는 다른 클래스 또는 외부 요소와 독립적으로 디자인하여야 한다. 

- `객체(Object)` - 클래스의 인스턴스(실제로 메모리상에 할당된 것)이다. 객체는 자신 고유의 속성(attribute)을 가지며 클래스에서 정의한 행위(behavior)를 수행할 수 있다. 객체의 행위는 클래스에 정의된 행위에 대한 정의를 공유함으로써 메모리를 경제적으로 사용한다.

- `메서드(Method), 메시지(Message) `- 클래스로부터 생성된 객체를 사용하는 방법으로서 객체에 명령을 내리는 메시지라 할 수 있다. 메서드는 한 객체의 서브루틴(subroutine) 형태로 객체의 속성을 조작하는 데 사용된다. 또 객체 간의 통신은 메시지를 통해 이루어진다.

<br>

### 객체지향 프로그래밍의 4가지 특성

#### 1. 추상화 (Abstraction)

추상화란 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것을 의미한다.

예를 들어, 

- 김싸피에게는 SSAFY, Vote24, 도와주개냥, JTDA, 취준생 등의 특징이 있으면 이중 코드로 나타낼 때, SSAFY, 취준생의 특징만 뽑아내거나 간추려서 나타내는 것을 말함.
- '평생 못 사는 자동차'라는 추상화 집합을 만들어두고, 평생 못 사는 자동차들이 가진 공통적인 특징들 (매우 비쌈, 빵빵한 배기음 등) 을 만들어 활용하면 된다.

<br>

#### 2. 캡슐화 (Encapsulation)

캡슐화는 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것을 의미한다.

쉽게 말하면, **한 곳에서 변화가 일어나도 다른 곳에 미치는 사이드 이펙트를 최소화** 시키는 것을 의미한다. 

즉, 객체 내부의 **어떤 동작에 대한 구현이 어떻게 되어있는지 감추는 것**이다. 이를 통해 외부에서 뭔가 잘못 건드려 객체를 손상시키는 일을 방지할 수 있다.

**`결합도`란 어떤 기능을 실행할 때 다른 클래스나 모듈에 얼마나 의존적인지**를 나타내는 지표이다. 객체 간의 독립성을 강조하기 위해 **의존도가 최대한 낮게 만드는 것이 중요**하다.

 때문에 소프트웨어 공학적으로, **객체 내의 모듈 간의 요소가 밀접한 관련이 있는 것으로 구성하여 응집도를 높이고**, **결합도를 줄여야 요구사항 변경에 대처하는 좋은 설계**라고 배운다.

##### 방법

정보 **은닉화를 통해 `높은 응집도, 낮은 결합도`를 유지**할 수 있도록 설계한다.
외부에서 접근할 필요 없는 것들은 접근 지정자를 **`private` 으로 두어 접근에 제한**을 두는 것이다. 

외부 객체는 객체 내부의 구조를 모르게 하고, 해당 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있도록 하여 의도하지 않은 동작 오류를 방지하고 유지보수 효율을 높일 수 있다.

<br>

#### 3. 상속성

상속성은 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것을 말한다.

코드의 재사용 측면, 계층적인 관계 생성, 유지 보수성 측면에서 중요하다.

여러 개체들이 지닌 **공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립**하는 과정 (일반화)

상속은 **자식 클래스를 외부로부터 은닉**하는 **캡슐화의 일종**이다.

'평생 못 사는 차'를 통해 추상화를 설명했었는데, 조금 더 나아가 **'쌉부자' 클래스**가 있다고 가정해보자. 

이 때, **평생 못 사는 자동차의 자식 클래스에 해당하는 람보르기니, 페라리, 맥라렌 등은 캡슐화를 통해 은닉해둔 상태**이다. **쌉부자의 관점**으로는, 구체적인 **자동차 종류가 숨겨져 있는 상태**다. 자동차를 수집하고 싶은 쌉부자 입장에서는 자동차 **종류가 어떤 것이든, 구매하는 데에 크게 중요하지 않다**. 그냥 남들이 평생 못 사는 자동차면 된다. 그 어떤 **값비싼 차가 추가**된다고 해도, **쌉부자에겐 영향이 없어야 한다는 점이 가장 중요**하다. 따라서 **캡슐화를 통해 쌉부자 입장에선 확인할 수 없도록** 하는 것이다.

이처럼, 상속 관계에서는 단순히 하나의 클래스 안에서 **속성, 메소드들의 캡슐화에 한정되지 않는다**. 

즉 **자식 클래스 또한 캡슐화되어 '쌉부자'와 같은 외부 클래스에 은닉**하는 것으로 확장되는 것이다.

이렇듯 **자식 클래스를 캡슐화**해두면, **외부에선 개별적인 자식 클래스들과 무관하게 개발을 이어갈 수 있는 장점**이 있다.

<br>

### 4. 다형성 (Polymorphism)

다형성은 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것을 말한다. 

서로 다른 클래스의 객체가 같은 동작 수행 명령을 받았을 때, **각자의 특성에 맞는 방식으로 동작**하는 것.

객체지향 패러다임의 핵심이다. **다형성은 상속과의 시너지가 엄청나다**. 다형성 구현을 통해 **코드를 간결하게 해주고, 유연함을 갖추게** 해준다. 또한, 구체적으로 현재 어떤 클래스 객체가 참조되는 지는 무관하게 **헐렁하게 프로그래밍하는 것이 가능**하다.

<br>

평생 못 사는 차들은 배기음이 각기 다르고 고유의 감성이 있어 자동차 덕후들에게 사랑받는다. 위 예시에서 '평생 못 사는차'라는 개념을 일반화(상속)하여 **람보르기니, 페라리** 등의 객체를 만들었는데, **평생 못 사는 차라는 클래스의 '배기음 출력' 이라는 메소드를 실행**했을 때, **자식 클래스들이 각기다른 배기음을 내뿜는 것이 다형성이 부각된 부분**이다.



<hr>

### 예상 질문

Q. OOP의 장점은?

소프트웨어 공학의 관점에서 볼 때 S/W의 질을 향상하기 위해 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 지향해야 하는데, OOP의 경우 하나의 문제 해결을 위한 데이터를 클래스에 모아 놓은 데이터형을 사용함으로써 응집력을 강화하고, 클래스간에 독립적인 디자인을 함으로써 결합력을 약하게 한다.

Q. oop의 특징 4가지

추상화, 캡슐화, 상속성, 다형성



<hr>

참고자료

- 위키백과
- https://velog.io/@haero_kim/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0