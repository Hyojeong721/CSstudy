# Process & Thread



## 용어 정리



### 프로그램(Program)

- 어떤 작업을 위해 운영체제 위에서 **실행할 수 있는** 파일

- 명령어, 코드 및 정적인 데이터의 묶음

  ​

### 프로세스(Process) 

- 운영체제 위에서 **실행중인** 프로그램

- 프로그램 명령어와 데이터들이 메모리에 올라오고 실행 중 또는 실행 대기중인 상태

  ​

### 프로세서(Processor)

- 프로세스가 **동작**될 수 있도록 하는 **하드웨어**(=cpu)

- 동작 : 프로그램의 자원들이 메모리에 올라오고, 실행 되어야 할 코드의 메모리 주소를 CPU의 레지스터로 올리는 것.

  ​

### 쓰레드(Thread)

- 프로세스 내에서 실행되는 흐름의 단위
- 프로세스의 특정한 수행 경로
- 프로세스가 할당받은 자원을 이용하는 실행의 단위
- 프로세스의 Text, data, heap 영역을 공유한다.



##### 따라서, **프로세스**는 메모리에 적제되어 **프로세서**에 의해 실행중인 **프로그램**이고

**쓰레드는 프로세스 내에서 자원을 공유하며 실행되는 흐름의 단위이다.**



------



## 프로세스의 구성





![프로세스 구성 요소](https://user-images.githubusercontent.com/32683894/87295971-02476180-c541-11ea-8530-9a23e640c982.jpg)



- Code 영역: Program의 코드, Binary Code 상태로 올라가게 되는데 이 영역을 뜻한다.

- Data 영역 : 전역변수, 정적변수의 할당

- Stack 영역 : 매개변수, 지역변수, 함수 호출시 전달되는 인수 값 등 임시적인 자료

- Heap 영역 : 동적으로 할당되는 메모리

  ​

## 프로세스의 상태 (Life Cycle)



![image](https://user-images.githubusercontent.com/32683894/87304922-9240d780-c550-11ea-94b4-3a1a7394b42d.png)



1. 생성 (new)
   - 프로세스가 생성되었지만 아직 승인 받지 못한 상태 (생성 중)
2. 준비완료 (Ready)
   - 중앙처리장치가 사용 가능하게 될 때 그것을 할당받을 수 있는 상태
3. 실행 (Running)
   - 프로세스가 중앙처리장치(CPU)를 차지하고 있는 상태
4. 대기 (Waiting)
   - Running 상태 였다가 입출력 처리 등을 하게 되면, 중앙처리장치를 양도하고 입출력 처리가 완료될 때까지 대기하고 있는 상태 (특별한 사건을 기다림)
5. 종료 ( terminated)
   - 프로세스 실행이 완료되고 할당된 CPU를 반납



------





## PCB (Process Control Block)



- 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳으로, 프로세스의 상태 정보를 저장하는 구조체이다.
- 프로세스 상태 관리와 문맥교환(Context Switching)을 위해 필요하다.
- PCB는 프로세스 생성 시 만들어지며 주기억장치에 유지된다.



PCB 는 특정 **프로세스에 대한 중요한 정보를 저장** 하고 있는 운영체제의 자료구조이다. 운영체제는 프로세스를 관리하기 위해 **프로세스의 생성과 동시에 고유한 PCB 를 생성** 한다. 프로세스는 CPU 를 할당받아 작업을 처리하다가도 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU 를 반환해야 하는데, 이때 작업의 진행 상황을 모두 PCB 에 저장하게 된다. 그리고 다시 CPU 를 할당받게 되면 PCB 에 저장되어있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행한다.



##### *PCB 에 저장되는 정보*

- 프로세스 식별자(Process ID, PID) : 프로세스 식별번호
- 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태를 저장
- 프로그램 카운터 : 프로세스가 다음에 실행할 명령어의 주소
- CPU 레지스터
- CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
- 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
- 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
- 어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등



#### Context Switching???

CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적제하는 과정을 의미한다. Context Switching 과정에서 Overhead가 발생하지만 그럼에도 전체적인 흐름에 도움이 되기 떄문에 꼭 필요한 작업이다.

즉, 실행중인 프로세스가 대기상태로 돌아가고 대기 중이던 프로세스가 실행되는 과정



##### 언제 발생할까?

- 우선순위가 높은, 급한 프로세스를 먼저 처리해야 할때
- 실행중인 프로세스가 CPU사용을 허가받은 시간을 모두 소모할때
- I/O 입출력을 위해 대기해야 할때



##### Overhead??

Context Switching을 할때 발생하는 간접적인 처리시간, 메모리 등을 의미한다.



------



## 쓰레드의 특징



- 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다.
- 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다.
- 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유한다. 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.
- 각각의 스레드는 별도의 **레지스터와 스택**을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다.
- 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있다.



##### 레지스터와 스택

- stack은 프로시저의 복귀 주소나, 지역 변수같이 일시적이고 독립적인 실행환경을 제공한다. **스레드는 하나의 독립적인 실행 단위이기 때문에 각각 해당 실행에 대한 독립적 stack을 가진다.**
- 스레드는 프로세스와 같이 CPU를 할당받고, 선점당할 수 있다. 따라서 문맥교환(Context Switching)이 발생하게 되므로 **실행하고 있는 코드의 지점을 저장하는 PC Register는 스레드마다 독립적으로 할당**되어야 한다.



------





## 멀티 스레드

- 같은 프로세스 내에서 두개 이상의 쓰레드가 동작
- 프로세스의 자원을 공유
- 향상된 응답성
- Context switching 비용이 적다. (**Context Switching :** 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정을 말합니다.)
- 자원을 공유하기 때문에 **충돌**을 주의해야한다. (데드락이 발생할 수 있다)



### 멀티 스레딩의 장점

프로세스를 이용하여 동시에 처리하던 일을 스레드로 구현할 경우 메모리 공간과 시스템 자원 소모가 줄어들게 된다. **스레드 간의 통신**이 필요한 경우에도 별도의 자원을 이용하는 것이 아니라 전역 변수의 공간 또는 동적으로 할당된 공간인 **Heap 영역**을 이용하여 데이터를 주고받을 수 있다. 그렇기 때문에 프로세스 간 통신 방법에 비해 스레드 간의 통신 방법이 훨씬 간단하다. 심지어 스레드의 context switch 는 프로세스 context switch 와는 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다. 따라서 시스템의 throughput 이 향상되고 자원 소모가 줄어들며 자연스럽게 프로그램의 응답 시간이 단축된다. 이러한 장점 때문에 여러 프로세스로 할 수 있는 작업들을 하나의 프로세스에서 스레드로 나눠 수행하는 것이다.

### 멀티 스레딩의 문제점



![멀티코어, 멀티쓰레드의 이론과 현실](https://www.goodgag.net/_data/up/1606/c36195766512443e661180005.jpg)



멀티 프로세스 기반으로 프로그래밍할 때는 프로세스 간 공유하는 자원이 없기 때문에 동일한 자원에 동시에 접근하는 일이 없었지만 멀티 스레딩을 기반으로 프로그래밍할 때는 이 부분을 신경써줘야 한다. 서로 다른 스레드가 데이터와 힙 영역을 공유하기 때문에 **어떤 스레드가 다른 스레드에서 사용중인 변수나 자료구조에 접근하여** 엉뚱한 값을 읽어오거나 수정할 수 있다.

그렇기 때문에 멀티스레딩 환경에서는 **동기화** 작업이 필요하다. 동기화를 통해 작업 처리 순서를 컨트롤 하고 공유 자원에 대한 접근을 컨트롤 하는 것이다. 하지만 이로 인해 병목현상이 발생하여 성능이 저하될 가능성이 높다. 그러므로 과도한 락으로 인한 병목현상을 줄여야 한다.



### 멀티 스레드 vs 멀티 프로세스

멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제를 안고 있다. 반면 멀티 프로세스 방식은 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 존재한다. 이 두 가지는 동시에 여러 작업을 수행한다는 점에서 같지만 적용해야 하는 시스템에 따라 적합/부적합이 구분된다. 따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택하고 적용해야 한다.



**EX)** **인터넷익스플로어 (Internet Explorer)** **VS** **크롬 (Chrome)**



------















예상질문



프로세스와 스레드의 차이?

프로세스의 상태?

멀티 스레드와 멀티 프로세스의 차이?