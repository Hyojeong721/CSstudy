# Part Network

- [HTTP 의 GET 과 POST 비교](https://github.com/Hyojeong721/CSstudy/tree/main/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC#http-get%EA%B3%BC-post)
- [TCP 3-way-handshake](https://github.com/Hyojeong721/CSstudy/tree/main/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC#tcp-3-way-handshake)
- [TCP와 UDP의 비교](https://github.com/Hyojeong721/CSstudy/tree/main/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC#cs-study--03-tcp--udp)
- [HTTP 와 HTTPS](https://github.com/Hyojeong721/CSstudy/tree/main/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC#http%EC%99%80-https)
- [DNS](https://github.com/Hyojeong721/CSstudy/tree/main/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC#dns)
- 웹 통신의 큰 흐름





# HTTP GET과 POST

## HTTP 메서드

HTTP 메서드란 클라이언트가 `웹 서버에게 사용자 요청의 목적이나 종류를 알리는 수단`이다.

![image](https://user-images.githubusercontent.com/97162920/174619702-21675692-c7a1-45d7-9c93-1066c3c49cc4.png)

## GET

클라이언트에서 서버에게 `정보를 요청`하기 위해 사용되는 메서드

요청하는 정보가 HTTP의 `header에 담겨 전송`된다. 즉, url의 ? 뒤에 데이터가 붙어서 요청된다.

url 글자수에 제한이 있기 때문에 GET 요청의 `데이터 크기에도 제한`이 있을 수 밖에 없다.

데이터가 url에 그대로 노출되기 때문에 POST 요청에 비해 `보안에 취약`하다.

`idempotent`하다(멱등성) - 같은 요청을 여러번 보내도 매번 같은 응답이 온다. →can be cached

## POST

클라이언트에서 서버로 리소스를 새로 생성하거나 업데이트하기 위해 사용되는 메서드

요청하는 정보가 HTTP의 `body에 담겨 전송`된다. 데이터 크기의 제한이 없다.

idempotent하지 않다. 요청을 보낼 때 마다 같은 응답이 온다는 보장이 없다. → not cached


---

참고

[[HTTP] HTTP Method 정리 / GET vs POST 차이점 :: Code Playground (tistory.com)](https://im-developer.tistory.com/166)

<br>

<hr>

<br>

# TCP 3-way HandShake



### TCP?

두 개의 호스트를 연결하고 데이터 스트림을 교환하게 해주는 중요한 네트워크 프로토콜이다. **TCP**는 데이터와 패킷이 보내진 순서대로 전달하는 것을 보장해준다.

------





### TCP 3-way HandShake?

TCP 3-way HandShake는 TCP/IP 프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방과 사전에 세션을 수립하는 과정을 의미한다.



#### 역할

양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장, 실제로 데이터를 전송하기 전 서로가 준비되었는지 알 수 있도록 함.

양쪽 모두 상대편에 대한 초기 순차일련번호를 얻을 수 있도록 함.



#### 과정



![img](https://t1.daumcdn.net/cfile/tistory/2352F94A58D7287932)



1) 클라이언트는 서버에 접속을 요청하는**SYN(M)**패킷을 보낸다.
2) 서버는 클라이언트의 요청인 **SYN(M)**을 받고 클라이언트에게 요청을 수락한다는 **ACK(M+1)**와 **SYN(N)**이 설정된 패킷을 발송한다.
3) 클라이언트는 서버의 수락 응답인**ACK(M+1)**와**SYN(N) **패킷을 받고**ACK(N+1)**를 서버로 보내면 연결이 **성립(establish)**된다.



------







### TCP 4-way HandShake?

TCP 4-way HandShake는 TCP 3-way HandShake와 반대로 세션을 종료하기 위해 수행되는 절차이다.



#### 과정

![img](https://t1.daumcdn.net/cfile/tistory/2336285058D7288E33)



1) 클라이언트가 연결을 종료하겠다는 **FIN플래그**를 전송한다.

2) 서버는 클라이언트의 요청**(FIN)**을 받고 알겠다는 확인 메세지로**ACK**를 보낸다.

2-1) 그리고나서는 데이터를 모두 보낼 때까지 잠깐**TIME_OUT**이 된다.

3) 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 클라이언트에게**FIN 플래그**를 전송한다.

4) 클라이언트는**FIN 메세지**를 확인했다는**메세지(ACK)**를 보낸다.

5) 클라이언트의**ACK 메세지**를 받은 서버는 소켓 **연결을 close**한다.

6) 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간(Default: 240sec) 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다.**(TIME_WAIT)**

------



#### 플래그 정보

TCP Header에는 CONTROL BIT(플래그 비트, 6bit)가 존재하며, 각각의 bit는 "URG-ACK-PSH-RST-SYN-FIN"의 의미를 가진다.

즉, 해당 위치의 bit가 1이면 해당 패킷이 어떠한 내용을 담은 패킷인지를 나타낸다.



**SYN** (synchronize sequence number) / 000010

연결 설정. Sequence Number를 랜덤으로 설정하여 세션을 연결하는 데 사용하며, 초기에 Sequence Number를 전송한다.



**ACK** (acknowledgement) / 010000

응답 확인. 패킷을 받았다는 것을 의마한다.

Acknowledgement Number 필드가 유효한지를 나타낸다.



**FIN** (Finish) / 000001

연결 해제. 세션 연결을 종료시킬 때 사용되며, 더 이상 전송할 데이터가 없음을 의미한다.



------



### 관련 질문



**왜 3 way handshake(3단계) 일까 2 way handshake(2단계)는 안될까?**



TCP 연결이 양방향성 연결이기 때문에 그렇다.

서버에서도 클라이언트에게 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야한다.



**TCP의 연결 설정 과정(3단계)과 연결 종료 과정(4단계)이 단계가 차이나는 이유?**



Client가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 때문이다.



**만약 Server에서 FIN 플래그를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?**



이러한 현상에 대비하여 Client는 Server로부터 FIN 플래그를 수신하더라도 일정시간(Default: 240sec)동안 세션을 남겨 놓고 잉여 패킷을 기다리는 과정을 거친다. (TIME_WAIT 과정)



**초기 Sequence Number인 ISN을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유?**



Connection을 맺을 때 사용하는 포트(Port)는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다. 서버 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순처적인 Number가 전송된다면 이전의 Connection으로부터 오는 패킷으로 인식할 수 있다. 이런 문제가 발생할 가능성을 줄이기 위해서 난수로 ISN을 설정한다.

<br>

<hr>

<br>

# CS study : 03 TCP & UDP

> [Interview_Question_for_Beginner](https://github.com/JaeYeopHan/Interview_Question_for_Beginner)/**DataStructure**/
>
> [개념 정리 - (8) 컴퓨터 네트워크 편 by 정주홍](https://brunch.co.kr/@toughrogrammer/16)

- 위 repository 를 읽고 정리한 글입니다.

## OSI 7 layers

- 인터넷 프로토콜 스위트(internet protocol suite) 는 인터넷에서 컴퓨터들이 서로 정보를 주고 받는 데 쓰이는 프로토콜의 집합이다.
- 프토로콜의 네트워킹 범위에 따라 다음과 같이 추상화 계층으로 나눈다. 이 계층들은 특정 계층이 변경되었을 때 다른 계층이 영향을 받지 않도록 유연하게 설계되어 있다.

<img src="C:\Users\USER\Desktop\CSstudy\네트워크\HTTP_image\network_layer.jpg" alt="max-heap"/>

<br />

1. 물리 계층 (Physical Layer)

   - 실제 장치를 연결하기 위한 전기적 / 물리적 세부 사항을 정의한 계층
   - 다만, 데이터가 무엇인지, 에러가 있는 지 등에는 전혀 신경쓰지 않고, 데이터를 전기적인 신호로 변환해서 주고 받는 기능만 한다.
   - 인터넷 케이블, 라우터 스위치 등

2. 데이터 링크 계층 (Data Link Layer)

   - 장치 간 신호를 전달하는 물리 계층을 이용하여 네트워크 상의 주변 장치들 간의 데이터를 전송하는 역할을 한다.
   - 물리 계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보의 전달을 수행할 수 있도록 돕는다.

3. 네트워크 계층 (Network Layer)

   - 전송 계층에서 보내려는 패킷을 목적지 노드까지 도착시키는 것
   - 현재 라우터에서 연결된 라우터 중 어떤 라우터로 보내는 것이 목적지까지의 최적 경로인지 결정하는 `라우팅` 을 수행한다.
   - 라우팅을 수행하면 어떤 헤더를 가진 패킷을 어떤 링크로 전송하라는 정보가 정리된 `포워딩 테이블` 이 생성된다.

4. 전송 계층 (Transport Layer)

   - 통신을 활성화하기 위해 포트를 열어 응용 프로그램들이 전송을 할 수 있도록 한다.

5. 세션 계층 (Session Layer)

   - 응용 프로세스가 통신을 관리하는 방법을 제공한다.
   - 이 계층의 프로토콜을 통해, 통신 연결이 손실되는 경우 연결 복구 시도가 가능하다.

6. 표현 계층 (Presentation Layer)

   - 코드 간 번역을 담당하는 계층으로, 인코딩이나 암호화 등의 동작이 이루어진다.
   - 응용 계층(사용자 시스템)에서 데이터 형식 상 차이를 다루는 부담을 덜어준다.

7. 응용 프로그램 계층 (Application Layer)

   - 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행하는 계층
   - 사용자에게 직접적으로 보이는 부분이며 상호작용 한다.
   - ex) 웹 브라우저, 응용 프로그램 (Outlook, Email, Skype ...)

A-P-S-T-N-D-P
아페서 터(지)니 뒤(에서) 피(가 나더라)
<br />

### 계층 간 데이터 송수신 과정

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8d/OSI_Model_v1.svg/870px-OSI_Model_v1.svg.png" alt="max-heap" style="zoom: 50%;"/>

데이터 단위

- 애플리케이션 계층: Message
- 전송 계층: Segment(TCP), Datagram(UDP)
- 네트워크 계층: Packet
- 데이터링크 계층: Frame
- 물리 계층: Bit

---

## 전송 계층 (Transport Layer)

전송 계층은 송신자와 수신자를 연결하는 통신 서비스를 제공하며, 애플리케이션과 인터넷 계층 사이의 데이터가 전달될 때의 중계 역할을 한다.

연결 지향 데이터 스트림, 신뢰성, 흐름 제어, 다중화와 같은 편리한 서비스를 제공한다.

1. `UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)`

- 비연결형 프로토콜:
- 순서를 보장하지 않고, 수신 여부를 확인하지 않으며 단순히 데이터만 주는 `데이터그램 패킷 교환 방식` 을 사용한다.
  - 데이터그램 패킷 교환 방식은, 패킷이 독립적으로 이동하며 최적의 경로를 선택하여, 하나의 메시지에서 분할된 여러 패킷은 서로 다른 경로로 전송될 수 있으며 도착한 **순서 또한 다를 수** 있는 방식을 뜻한다.

<br/>

2. `TCP(Transmission Control Protocol, 전송제어 프로토콜)`

- 대부분의 인터넷 응용 분야들은 신뢰성과 순차적인 전달 을 필요로 한다. UDP 로는 이를 만족시킬 수 없으므로 다른 프로토콜이 필요하여 탄생한 것이 TCP이다.

- 패킷 사이의 순서를 보장하고 연결지향 프로토콜을 사용해 연결하여, 신뢰성을 구축하고 수신 여부를 확인하며 `가상회신 패킷 교환 방식` 을 사용한다.
  - 가상 회신 패킷 교환 방식은 각 패킷에는 가상회선 식별자가 포함되며, 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 **순서대로** 도착하는 방식을 말한다. (송신 호스트에서 수신 호스트까지 하나의 회선을 선택하여 전송된다.)

UDP 프로토콜은 TCP 가 제공하는 여러 서비스를 제공하지 않기 때문에, 부하가 매우 적다. 따라서 많은 요청을 처리하고 신뢰성이 떨어져도 괜찮은 서비스들에서 유용하게 쓰인다.

DNS, VoIP(음성 인터넷 프로토콜), 온라인 게임 서버 등에서 쓰인다.

---

### TCP 제공 서비스

#### 연결 제어

TCP 프로토콜에서 통신이 이루어지기 위해서는 먼저 서로 연결되어야 하고, 서로 임의의 시작 순서 번호를 알려줘야 한다. 이 과정을, `TCP 3-way-handshaking` 라고 하며, 연결 종료 시엔 4-way-handshaking 을 통해 가능하다.

#### 흐름 제어

송신량과 수신 처리량을 일치시키는 것을 `흐름 제어` 라고 한다.

수신 측이 수신 가능한 양보다더 많은 데이터를 전송하려 해봤자, 수신 측의 버퍼에 남은 공간이 없다면 힘들게 전송한 데이터를 버리게 되므로, 수신 측이 처리할 수 있는 양만큼만 전송하도록 제어하는 서비스가 필요하다.

이를 위해 크게 Stop and Wait 방식과, Sliding Window 방식이 사용된다.

#### 혼잡 제어

네트워크가 혼잡하다고 판단되어 데이터 송신량을 떨어뜨리는 것을 `혼잡 제어`라고 한다.

신뢰성 있는 데이터 전송 알고리즘에 의하면, 네트워크 망이 처리 가능한 데이터량을 넘어서는 데이터량이 전송되는 경우, 전송 실패한 데이터를 다시 전송 시도하여 악순환이 반복되므로 혼잡 제어가 필요하다.

#### 다중화

응용 프로그램이 소켓을 통해 데이터를 전송하는 것부터 TCP 프로토콜이 시작된다. 그러나 한 컴퓨터에 여러 소켓과 프로세스가 존재할 수 있기 때문에, OS 에서는 소켓과 프로세스를 식별하기 위해 포트(port) 번호를 따로 둔다.

보통 컴퓨터에 연결된 통신 링크는 하나이기 때문에, 하나의 링크를 통해 여러 소켓의 데이터를 주고 받아야 한다. 이를 위해 OS 에서는 전송하려는 데이터를 TCP/UDP 세그먼트로 만들 때 헤더를 추가하여 공통적으로 출발지 포트 번호와 목적지 포트 번호를 둔다.

이러한 작업을 `다중화(Multiplexing)` 이라고 하며, 목적지에 도착한 세그먼트의 헤더를 확인하여 `Demultiplexing` 을 통해 대상 소켓에게 데이터를 전달한다.

<br>

<hr>

<br>



# HTTP와 HTTPS

### HTTP란?

HTTP는 Hyper Text Transfer Protocol의 약자로, **서버/클라이언트 간 데이터를 주고받을 때 쓰는 통신 규약**으로, WWW(월드와이드웹)상에서 웹페이지나 이미지 같은 정보를 요청과 응답에 의해 주고받는 프로토콜입니다. 

```
프로토콜이란?

사람과 사람이 통신할 때 서로 이해할 수 있는 언어, 공용된 언어를 사용해 전세계 모든 사람과 대화할 수 있다라고 하면, 
컴퓨터와 컴퓨터도 서로 이해 할 수 있는 언어, 공용된 언어를 사용 해야 한다는 것인데 
이것이 바로 프로토콜(Protocol) 입니다.
```

즉, HTTP는 인터넷에서 하이퍼텍스트를 교환하기 위한 통신 규약으로, **80번 포트**를 사용하고 있다. 
따라서 HTTP 서버가 80번 포트에서 요청을 기다리고 있으며, 클라이언트는 80번 포트로 요청을 보내게 된다.

HTTP는 1989년 팀 버너스 리(Tim Berners Lee)에 의해 처음 설계되었으며, WWW(World-Wide-Web) 기반에서 세계적인 정보를 공유하는데 큰 역할을 하였다.

<br>

- 애플리케이션 레벨의 프로토콜

- **TCP/IP 위**에서 작동

  ```
  TCP/IP 는 도청 가능한 네트워크이다.
  TCP/IP 구조의 통신은 전부 통신 경로 상에서 엿볼 수 있다. 패킷을 수집하는 것만으로 도청할 수 있다. 평문으로 통신을 할 경우 메시지의 의미를 파악할 수 있기 때문에 암호화하여 통신해야 한다.
  ```

- 상태를 가지고 있지 않는 **Stateless(무상태성)** 프로토콜

  ```
  무상태란?
  
  Connectionless로 인해 서버는 클라이언트를 식별할 수가 없는데, 이를 Stateless라고 합니다.
  클라이언트의 상태를 모른다는 것은 예를 들면 다음과 같습니다.
  (쇼핑몰에 접속 -> 로그인 -> 상품 클릭 -> 상세화면으로 이동 -> 로그인 -> 주문 -> 로그인 ...)
  즉, 매번 새로운 인증을 해야하는 번거로움이 발생하게 됩니다.
  
  상태를 기억하는 방법?
  
  1. 쿠키 : 브라우저 단에서 쿠키라는 것을 저장하여 서버가 클라이언트를 식별할 수 있도록 합니다.
  - 쿠키는 사용자 정보가 브라우저에 저장되기 때문에 공격자로부터 위변조의 가능성이 높아 보안에 취약합니다.
  
  2. 세션 : 세션은 브라우저가 아닌 서버단에서 사용자 정보를 저장하는 구조입니다.
  - 따라서 쿠키보다는 안전하다고 할 수 있지만 세션 정보도 중간에 탈취 당할 수 있기 때문에 보안에 완벽하다고 할 수 없습니다.
  - 세션을 사용하면 서버의 메모리를 차지하게 되고, 만약 동시 접속자 수가 많은 서비스일 경우에는 서버 과부화의 원인이 됩니다.
  
  3. 토큰을 사용하는 OAuth, JWT : 보호할 데이터를 토큰으로 치환하여 원본 데이터 대신 토큰을 사용하는 기술입니다.
  - 쿠키와 세션의 문제점들을 보완하기 위해 탄생
  - 중간에 공격자로부터 토큰이 탈취당하더라도 데이터에 대한 정보를 알 수 없으므로, 보안성을 높은 기술이라 할 수 있습니다.
  
  But!!! 
  
  서비스에 따라 기술의 특징을 잘 이해하여 때에 따라 쿠키, 세션, OAuth, JWT 등을 적절히 사용하는 것이 좋습니다. 
  (무조건 토큰 짱 아님)
  
  
  ```

- 비연결성 ( Connectionless )

  ```
  비연결성 ( Connectionless )
  
  비연결성은 클라이언트와 서버가 한 번 연결을 맺은 후, 클라이언트 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊어버리는 성질을 말합니다.
  
  1) 비연결성의 장점
  
  HTTP 프로토콜은 왜 한 번 맺은 연결을 끊어버리는걸까요?
  
  HTTP는 인터넷 상에서 불특정 다수의 통신 환경을 기반으로 설계되었습니다.
  
  만약 서버에서 다수의 클라이언트와 연결을 계속 유지해야 한다면, 이에 따른 많은 리소스가 발생하게 됩니다.
  
  따라서 연결을 유지하기 위한 리소스를 줄이면 더 많은 연결을 할 수 있으므로 비연결적인 특징을 갖습니다.
  
  
  2) 비연결성의 단점
  
  서버는 클라이언트를 기억하고 있지 않으므로 동일한 클라이언트의 모든 요청에 대해, 매번 새로운 연결을 시도/해제의 과정을 거쳐야하므로 연결/해제에 대한 오버헤드가 발생한다는 단점이 있습니다.
  
  
  ```

  

- 암호화가 되지 않은 **평문 데이터를 전송**하는 프로토콜

  => HTTP로 비밀번호나 주민등록번호 등을 주고 받으면 제 3자가 정보를 조회할 수 있었다.  그래서 탄생한 것이 HTTPS!!

<br>

### HTTP 응답 코드

- 100 - 109 : 메시지 정보
- 200 - 206 : 요청 성공
- 300 - 305 : 리다이렉션
- 400 - 415 : 클라이언트 에러
- 500 - 505 : 서버에러

<br>

### HTTP 구조

```
Method, Path, Version, Headers, Body 등으로 구성
```

<img src="C:\Users\USER\Desktop\CSstudy\네트워크\HTTP_image\http구조.png" style="zoom: 67%;" > <img src="C:\Users\USER\Desktop\CSstudy\네트워크\HTTP_image\http구조1.png" style="zoom: 70%;" >

<br>

### HTTPS란?

HTTP에 데이터 암호화가 추가된 프로토콜이다.

(HyperText Transfer Protocol over Secure Socket Layer, HTTP over TLS, HTTP over SSL, HTTP Secure 등으로 불림)

HTTPS는 HTTP와 다르게 **443번 포트**를 사용하며, 네트워크 상에서 중간에 제3자가 정보를 볼 수 없도록 **암호화를 지원**하고 있다.

<img src="C:\Users\USER\Desktop\CSstudy\네트워크\HTTP_image\구조.png">

<br>

#### <암호화 방식>

HTTPS는 대칭키 암호화 방식과 비대칭키 암호화 방식을 모두 사용한다.

##### 대칭키 암호화

- 클라이언트와 서버가 `동일한 키를 사용`해 암호화/복호화를 진행
- 키가 노출되면 위험하지만 연산 속도가 빠름

**비대칭키 암호화**

- 1개의 쌍으로 구성된 `공개키와 개인키`를 암호화/복호화 하는 데 사용함
- 키가 노출되어도 비교적 안전하지만 연산 속도가 느림

```
공개키와 개인키는 서로를 위한 1쌍의 키이다.

공개키: 모두에게 공개가능한 키
개인키: 나만 가지고 알고 있어야 하는 키
```

- 공개키 vs 개인키 암호화
  - 공개키 암호화 : 개인키로만 복호화 = 나만 볼 수 있음
  - 개인키 암호화 : 공개키로만 복호화 = 모두가 볼 수 있음, 내가 인증한 정보임을 알려 신뢰성 보장 가능.

<img src="C:\Users\USER\Desktop\CSstudy\네트워크\HTTP_image\암호화.png" style="zoom: 80%;" >



### HTTPS 동작 과정

HTTPS는 대칭키 암호화와 비대칭키 암호화를 모두 사용 => 안정성 + 빠른 연산 속도

HTTP 통신하는 소켓 부분을 `SSL(Secure Socket Layer)` or `TLS(Transport Layer Security)`라는 프로토콜로 대체하는 것 

```
데이터를 송신할 때,

HTTP는 애플리케이션 계층(HTTP) 에서 전송 계층(TCP)로 보내지만, HTTPS는 SSL로 전송하고 SSL은 받은 데이터를 암호화하여,전송계층(TCP)로 전달해는 방식으로 데이터를 송신한다. 

데이터를 수신할 때, HTTP는 전송 계층(TCP)에서 애플리케이션 계층(HTTP)로 보내지만, HTTPS는 전송계층(TCP)에서 SSL로 보내고, SSL은 복호화하여 애플리케이션 계층(HTTPS)로 전달하여 데이터 수신한다.

송신할 때는 HTTP는 TCP를 SSL로 인식하고, 수신할 때는 TCP가 HTTP를 SSL로 인식하게 함으로써 동작하기 때문에 
기존 전달 방식을 그대로 사용 가능
```



```
소켓?
기본적으로 소켓은 통신을 위한 일종의 통로라고 생각할 수 있습니다. 
두 프로그램이 네트워크를 통해 서로 통신을 수행할 수 있도록 양쪽에 생성되는 링크의 단자입니다.
두 소켓이 연결되면 서로 다른 프로세스끼리 데이터를 전달할 수 있습니다.
결국 소켓이 구현됨으로써 네트워크 및 전송 계층의 캡슐화가 가능해집니다. 


SSL?
SSL(Secure Sockets Layer)은 암호화 기반 인터넷 보안 프로토콜. 
인터넷 통신의 개인정보 보호, 인증, 데이터 무결성을 보장하기 위해 Netscape가 1995년 처음으로 개발. 
SSL은 현재 사용 중인 TLS 암호화의 전신입니다.

TLS?
SSL == TLS 같은 말입니다. 네스케이프에 의해서 SSL이 발명되었고, 이것이 점차 폭넓게 사용되다가 표준화 기구인 IETF의 관리로 변경되면서 TLS라는 이름으로 바뀌었다. TLS 1.0은 SSL 3.0을 계승한다. 하지만 TLS라는 이름보다 SSL이라는 이름이 훨씬 많이 사용되고 있다.
```



#### how?

> 처음 연결을 성립하여 안전하게 세션키를 공유하는 과정에서 비대칭키가 사용되는 것이고, 
> 이후에 데이터를 교환하는 과정에서 빠른 연산 속도를 위해 대칭키(세션키)가 사용되는 것이다.

1. 클라이언트(브라우저)가 서버로 최초 연결 시도를 함
2. 서버는 공개키(엄밀히는 인증서)를 브라우저에게 넘겨줌
3. 브라우저는 인증서의 유효성을 검사하고 세션키를 발급함
4. 브라우저는 세션키를 보관하며 추가로 서버의 공개키로 세션키를 암호화하여 서버로 전송함
5. 서버는 개인키로 암호화된 세션키를 복호화하여 세션키를 얻음
6. 클라이언트와 서버는 동일한 세션키를 공유하므로 데이터를 전달할 때 세션키로 암호화/복호화를 진행함



**여기서 잠깐!  [ HTTPS의 발급 과정 ] **

> 서버는 클라이언트와 세션키를 공유하기 위한 공개키를 생성해야 하는데, 
> 일반적으로는 인증된 기관(Certificate Authority)에 공개키를 전송하여 인증서를 발급 받는다.

1. A 기업은 HTTP 기반의 애플리케이션에 HTTPS를 적용하기 위해 CA 기업에게 돈을 지불하고 공개키를 저장하는 인증서 발급을 요청함.

2. CA 기업은 CA기업의 이름, 서버의 공개키, 서버의 정보 등을 기반으로 인증서를 생성하고 CA기업의 개인키로 암호화해서 제공.

3. A기업은 클라이언트에게 암호화된 인증서를 제공함.

4. 클라이언트는 CA기업의 공개키를 미리 다운받아 가지고 있어, 암호회된 인증서를 복호화하여 A기업의 공개키로 세션키를 공유함.


​	자체적으로 인증서 발급을 할 수 있고, 신뢰할 수 없는 CA기업에서 인증서 발급을 받는 경우도 있기 때문에, HTTPS를 지원한다면 무조건 안전한 건 아닙니다. 그런 경우, '주의 요함', '안전하지 않은 사이트'라고 알림이 뜹니다.



<img src="C:\Users\USER\Desktop\CSstudy\네트워크\HTTP_image\https과정.png" style="zoom: 33%;" > <img src="C:\Users\USER\Desktop\CSstudy\네트워크\HTTP_image\https발급.png" style="zoom: 67%;" >



<br>

### HTTP와 HTTPS

HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면, HTTPS는 안전하게 데이터를 주고받을 수 있다.

하지만 HTTPS를 이용하면 암호화/복호화 과정이 필요하므로 HTTP보다 속도가 느리다.(그러나 오늘날에는 거의 차이를 못 느낄 정도.)

또한, HTTPS는 인증서를 발급하고 유지하기 위한 추가 비용이 발생한다.

> **그렇다면 언제 HTTP를 쓰고, 언제 HTTPS를 쓰는 것이 좋겠는가?**
> 개인 정보와 같은 민감한 데이터를 주고 받아야 한다면 HTTPS를 이용해야 하지만, 
> 노출이 되어도 괜찮은 단순한 정보 조회 등 만을 처리하고 있다면 HTTP를 이용하면 된다.

하지만 최근에는 하드웨어의 발달로 인해 HTTPS를 사용하더라도 속도 저하가 거의 일어나지 않으며, 

새로운 표준인 HTTP 2.0을 함께 이용한다면 오히려 HTTPS가 HTTP보다 더 빠르게 동작한다. 

따라서 웹은 과거의 민감한 정보를 다룰 때만 HTTPS에 의한 암호화 통신을 사용하는 방식에서 

**현재 모든 웹 페이지에서 HTTPS를 적용하는 방향으로 바뀌어가고 있다.**

<br>

<hr>


### 예상질문



**Q. http와 https 통신 방식의 차이에 대해 설명해주세요.**

HTTP는 Hyper Text Transfer Protocol의 약자로, **서버/클라이언트 간 데이터를 주고받을 때 쓰는 통신 규약**으로, WWW(월드와이드웹)상에서 웹페이지나 이미지 같은 정보를 요청과 응답에 의해 주고받는 프로토콜입니다. 평문으로 통신하기 때문에 개인 정보 노출 등의 보안상 문제가 있습니다. 이를 해결하기 위한 것이 https입니다. 

HTTPS는 HTTP 메시지(텍스트)를 암호화하는 것이며, S는 **Secure Socket**, **통신 보안망**을 말하며, **공개키 암호화 방식**을 거칩니다.

<br>

**Q. 공개키 암호화 방식이 뭐죠?**

공개키 암호화 방식은 사전에 비밀키를 나눠가지지 않은 사용자들이 안전하게 통신할 수 있도록 설계된 것입니다. 암/복호화에 다른 암호통신을 위해 공개키와 개인키 2개의 키를 사용합니다. 

//++ 구체적 방법은 위에 참고++//

<br>

 **Q.  무상태와 비연결성에 대해 설명해주세요.**

**무상태성**은 연결을 끊는 순간 클라이언트와 서버의 통신이 종료되며 **상태 정보는 유지하지 않는 특성**이 있으며, 비연결성은 요청과 응답이 끝나면 세션이 끊기는 것을 말합니다. 서버 입장에선 통신 연결을 유지하지 않아 **리소스 낭비가 줄어드는 장점**이 있지만, 통신마다 **새로운 세션**을 열어야 하는 작업은 클라이언트가 서버에게 **요청 시마다 인증해야 하는** 단점이 있습니다.

//+++추가내용+++//

이런 단점을 극복하기 위해서 **HTTP1.1에서 Keep-Alive기능**을 제공하여 한 번에 여러 요청-응답이 가능해졌다. 

KeepAlive는 지정된 시간동안 서버와 클라이언트 사이에서 패킷 교환이 없을 경우, 상대방의 안부를 묻기위해 패킷을 주기적으로 보내는것을 말합니다. 이 때, 패킷에 반응이 없으면 접속을 끊게 됩니다. 하지만 이또한 주기적으로 클라이언트 상태를 체크한다는 점에서 완벽한 해결책은 아닙니다.

<br>

<hr>
#### 참고자료


출처: https://mangkyu.tistory.com/98 [MangKyu's Diary:티스토리]

출처: https://mindnet.tistory.com/entry/네트워크-쉽게-이해하기-9편-프로토콜-이란-Protocol-이란-무엇인가 [Mind Net:티스토리]

출처:https://victorydntmd.tistory.com/286

<br>

<hr>

<br>

# DNS

## Domain Name

IP주소를 사람이 이해하기 쉽게 문자 형식으로 나타낸 것.

도메인 네임을 컴퓨터가 이해할 수 있도록 IP 주소로 변환해주는 시스템이 바로 DNS(Domain Name System)이다.
<br/>
<br/>

+) 주소창에 www.naver.com을 치면 일어나는 일 ...
![image](https://user-images.githubusercontent.com/97162920/174620229-2ee3eaa6-c9e3-424e-99c4-823b8f9ef2ac.png)

## DNS Round-Robin

DNS 서버 구성 방식 중 하나

### Round-Robin

![image](https://user-images.githubusercontent.com/97162920/174620683-bf06cbd5-18c7-4fd6-a7e2-39d2ee497cbc.png)
대표적인 스케줄링 기법

- 선점형 스케줄링
- 우선순위를 두지 않음
- 들어오는 순서대로, 주어진 시간만큼 돌아가면서 실행

DNS를 RR로 구성할 경우 로드밸런서가 필요 없다!

하지만 다음과 같은 단점이 있다.

- 서버의 수만큼 공인 IP의 수가 필요하다
- 균등하게 분산되지 않는다
- 서버가 다운되어도 확인할 수 없다

다음과 같은 방법으로 극복할 수 있다.

- 다중과 구성 방식
- 가중치 편성 방식
- 로드밸런스를 도입한 최소 연결 방식
  <br/>

위 내용에 대해 더 자세하게 알고싶다면 - 
[DNS round robin 방식이란? - Problem/Question (fc2.com)](http://dailusia.blog.fc2.com/blog-entry-362.html)

---

## 로드 밸런싱

서비스의 규모가 커지고 이용자 수가 많아지면 기존의 서버로 원활한 서비스를 제공하기 어려워진다.
이때 **scale-up** 혹은 **scale-out** 방식으로 문제를 해결할 수 있다.

- scale-up: 기존 서버의 성능을 UP 시키는 방식
- scale-out: 기존 서버와 동일하거나 낮은 수준의 서버를 증설하는 방식

scale-out 방식을 사용하려 한다면, 로드 밸런싱으로 여러대의 서버에 트래픽을 균등하게 분산해줘야 한다.
![image](https://user-images.githubusercontent.com/97162920/174621324-eefe3bdf-5495-4f2b-9b5c-da22d84653de.png)

### L4 로드밸런서와 L7 로드밸런서 

![image](https://user-images.githubusercontent.com/97162920/174622844-da08064f-68f3-4351-8b23-48b8e01a6fe8.png)

참고블로그
https://tecoble.techcourse.co.kr/post/2021-11-07-load-balancing/

<br>

<hr>

<br>

# 웹 통신의 큰 흐름

<img src="C:/Users/USER/Desktop/CSstudy/네트워크/웹흐름_image/웹흐름.png">

