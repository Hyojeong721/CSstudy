# TCP 3-way HandShake



### TCP?

두 개의 호스트를 연결하고 데이터 스트림을 교환하게 해주는 중요한 네트워크 프로토콜이다. **TCP**는 데이터와 패킷이 보내진 순서대로 전달하는 것을 보장해준다.

------





### TCP 3-way HandShake?

TCP 3-way HandShake는 TCP/IP 프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방과 사전에 세션을 수립하는 과정을 의미한다.



#### 역할

양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장, 실제로 데이터를 전송하기 전 서로가 준비되었는지 알 수 있도록 함.

양쪽 모두 상대편에 대한 초기 순차일련번호를 얻을 수 있도록 함.



#### 과정



![img](https://t1.daumcdn.net/cfile/tistory/2352F94A58D7287932)



1) 클라이언트는 서버에 접속을 요청하는**SYN(M)**패킷을 보낸다.
2) 서버는 클라이언트의 요청인 **SYN(M)**을 받고 클라이언트에게 요청을 수락한다는 **ACK(M+1)**와 **SYN(N)**이 설정된 패킷을 발송한다.
3) 클라이언트는 서버의 수락 응답인**ACK(M+1)**와**SYN(N) **패킷을 받고**ACK(N+1)**를 서버로 보내면 연결이 **성립(establish)**된다.



------







### TCP 4-way HandShake?

TCP 4-way HandShake는 TCP 3-way HandShake와 반대로 세션을 종료하기 위해 수행되는 절차이다.



#### 과정

![img](https://t1.daumcdn.net/cfile/tistory/2336285058D7288E33)



1) 클라이언트가 연결을 종료하겠다는 **FIN플래그**를 전송한다.

2) 서버는 클라이언트의 요청**(FIN)**을 받고 알겠다는 확인 메세지로**ACK**를 보낸다.

2-1) 그리고나서는 데이터를 모두 보낼 때까지 잠깐**TIME_OUT**이 된다.

3) 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 클라이언트에게**FIN 플래그**를 전송한다.

4) 클라이언트는**FIN 메세지**를 확인했다는**메세지(ACK)**를 보낸다.

5) 클라이언트의**ACK 메세지**를 받은 서버는 소켓 **연결을 close**한다.

6) 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간(Default: 240sec) 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다.**(TIME_WAIT)**

------



#### 플래그 정보

TCP Header에는 CONTROL BIT(플래그 비트, 6bit)가 존재하며, 각각의 bit는 "URG-ACK-PSH-RST-SYN-FIN"의 의미를 가진다.

즉, 해당 위치의 bit가 1이면 해당 패킷이 어떠한 내용을 담은 패킷인지를 나타낸다.



**SYN** (synchronize sequence number) / 000010

연결 설정. Sequence Number를 랜덤으로 설정하여 세션을 연결하는 데 사용하며, 초기에 Sequence Number를 전송한다.



**ACK** (acknowledgement) / 010000

응답 확인. 패킷을 받았다는 것을 의마한다.

Acknowledgement Number 필드가 유효한지를 나타낸다.



**FIN** (Finish) / 000001

연결 해제. 세션 연결을 종료시킬 때 사용되며, 더 이상 전송할 데이터가 없음을 의미한다.



------



### 관련 질문



**왜 3 way handshake(3단계) 일까 2 way handshake(2단계)는 안될까?**



TCP 연결이 양방향성 연결이기 때문에 그렇다.

서버에서도 클라이언트에게 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야한다.



**TCP의 연결 설정 과정(3단계)과 연결 종료 과정(4단계)이 단계가 차이나는 이유?**



Client가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 때문이다.



**만약 Server에서 FIN 플래그를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?**



이러한 현상에 대비하여 Client는 Server로부터 FIN 플래그를 수신하더라도 일정시간(Default: 240sec)동안 세션을 남겨 놓고 잉여 패킷을 기다리는 과정을 거친다. (TIME_WAIT 과정)



**초기 Sequence Number인 ISN을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유?**



Connection을 맺을 때 사용하는 포트(Port)는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다. 서버 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순처적인 Number가 전송된다면 이전의 Connection으로부터 오는 패킷으로 인식할 수 있다. 이런 문제가 발생할 가능성을 줄이기 위해서 난수로 ISN을 설정한다.

