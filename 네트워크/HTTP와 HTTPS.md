# HTTP와 HTTPS

### HTTP란?

HTTP는 Hyper Text Transfer Protocol의 약자로, **서버/클라이언트 간 데이터를 주고받을 때 쓰는 통신 규약**으로, WWW(월드와이드웹)상에서 웹페이지나 이미지 같은 정보를 요청과 응답에 의해 주고받는 프로토콜입니다. 

```
프로토콜이란?

사람과 사람이 통신할 때 서로 이해할 수 있는 언어, 공용된 언어를 사용해 전세계 모든 사람과 대화할 수 있다라고 하면, 
컴퓨터와 컴퓨터도 서로 이해 할 수 있는 언어, 공용된 언어를 사용 해야 한다는 것인데 
이것이 바로 프로토콜(Protocol) 입니다.
```

즉, HTTP는 인터넷에서 하이퍼텍스트를 교환하기 위한 통신 규약으로, **80번 포트**를 사용하고 있다. 
따라서 HTTP 서버가 80번 포트에서 요청을 기다리고 있으며, 클라이언트는 80번 포트로 요청을 보내게 된다.

HTTP는 1989년 팀 버너스 리(Tim Berners Lee)에 의해 처음 설계되었으며, WWW(World-Wide-Web) 기반에서 세계적인 정보를 공유하는데 큰 역할을 하였다.

<br>

- 애플리케이션 레벨의 프로토콜

-  **TCP/IP 위**에서 작동

  ```
  TCP/IP 는 도청 가능한 네트워크이다.
  TCP/IP 구조의 통신은 전부 통신 경로 상에서 엿볼 수 있다. 패킷을 수집하는 것만으로 도청할 수 있다. 평문으로 통신을 할 경우 메시지의 의미를 파악할 수 있기 때문에 암호화하여 통신해야 한다.
  ```

- 상태를 가지고 있지 않는 **Stateless(무상태성)** 프로토콜

  ```
  무상태란?
  
  Connectionless로 인해 서버는 클라이언트를 식별할 수가 없는데, 이를 Stateless라고 합니다.
  클라이언트의 상태를 모른다는 것은 예를 들면 다음과 같습니다.
  (쇼핑몰에 접속 -> 로그인 -> 상품 클릭 -> 상세화면으로 이동 -> 로그인 -> 주문 -> 로그인 ...)
  즉, 매번 새로운 인증을 해야하는 번거로움이 발생하게 됩니다.
  
  상태를 기억하는 방법?
  
  1. 쿠키 : 브라우저 단에서 쿠키라는 것을 저장하여 서버가 클라이언트를 식별할 수 있도록 합니다.
  - 쿠키는 사용자 정보가 브라우저에 저장되기 때문에 공격자로부터 위변조의 가능성이 높아 보안에 취약합니다.
  
  2. 세션 : 세션은 브라우저가 아닌 서버단에서 사용자 정보를 저장하는 구조입니다.
  - 따라서 쿠키보다는 안전하다고 할 수 있지만 세션 정보도 중간에 탈취 당할 수 있기 때문에 보안에 완벽하다고 할 수 없습니다.
  - 세션을 사용하면 서버의 메모리를 차지하게 되고, 만약 동시 접속자 수가 많은 서비스일 경우에는 서버 과부화의 원인이 됩니다.
  
  3. 토큰을 사용하는 OAuth, JWT : 보호할 데이터를 토큰으로 치환하여 원본 데이터 대신 토큰을 사용하는 기술입니다.
  - 쿠키와 세션의 문제점들을 보완하기 위해 탄생
  - 중간에 공격자로부터 토큰이 탈취당하더라도 데이터에 대한 정보를 알 수 없으므로, 보안성을 높은 기술이라 할 수 있습니다.
  
  But!!! 
  
  서비스에 따라 기술의 특징을 잘 이해하여 때에 따라 쿠키, 세션, OAuth, JWT 등을 적절히 사용하는 것이 좋습니다. 
  (무조건 토큰 짱 아님)
  
  
  ```

- 비연결성 ( Connectionless )

  ```
  비연결성 ( Connectionless )
  
  비연결성은 클라이언트와 서버가 한 번 연결을 맺은 후, 클라이언트 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊어버리는 성질을 말합니다.
  
  1) 비연결성의 장점
  
  HTTP 프로토콜은 왜 한 번 맺은 연결을 끊어버리는걸까요?
  
  HTTP는 인터넷 상에서 불특정 다수의 통신 환경을 기반으로 설계되었습니다.
  
  만약 서버에서 다수의 클라이언트와 연결을 계속 유지해야 한다면, 이에 따른 많은 리소스가 발생하게 됩니다.
  
  따라서 연결을 유지하기 위한 리소스를 줄이면 더 많은 연결을 할 수 있으므로 비연결적인 특징을 갖습니다.
  
  
  2) 비연결성의 단점
  
  서버는 클라이언트를 기억하고 있지 않으므로 동일한 클라이언트의 모든 요청에 대해, 매번 새로운 연결을 시도/해제의 과정을 거쳐야하므로 연결/해제에 대한 오버헤드가 발생한다는 단점이 있습니다.
  
  
  ```

  

- 암호화가 되지 않은 **평문 데이터를 전송**하는 프로토콜

  => HTTP로 비밀번호나 주민등록번호 등을 주고 받으면 제 3자가 정보를 조회할 수 있었다.  그래서 탄생한 것이 HTTPS!!

<br>

### HTTP 응답 코드

- 100 - 109 : 메시지 정보
- 200 - 206 : 요청 성공
- 300 - 305 : 리다이렉션
- 400 - 415 : 클라이언트 에러
- 500 - 505 : 서버에러

<br>

### HTTP 구조

```
Method, Path, Version, Headers, Body 등으로 구성
```

<img src="HTTP_image\http구조.png" style="zoom: 67%;" > <img src="HTTP_image\http구조1.png" style="zoom: 70%;" >

<br>

### HTTPS란?

HTTP에 데이터 암호화가 추가된 프로토콜이다.

(HyperText Transfer Protocol over Secure Socket Layer, HTTP over TLS, HTTP over SSL, HTTP Secure 등으로 불림)

HTTPS는 HTTP와 다르게 **443번 포트**를 사용하며, 네트워크 상에서 중간에 제3자가 정보를 볼 수 없도록 **암호화를 지원**하고 있다.

<img src="HTTP_image\구조.png">

<br>

#### <암호화 방식>

HTTPS는 대칭키 암호화 방식과 비대칭키 암호화 방식을 모두 사용한다.

##### 대칭키 암호화

- 클라이언트와 서버가 `동일한 키를 사용`해 암호화/복호화를 진행
- 키가 노출되면 위험하지만 연산 속도가 빠름

**비대칭키 암호화**

- 1개의 쌍으로 구성된 `공개키와 개인키`를 암호화/복호화 하는 데 사용함
- 키가 노출되어도 비교적 안전하지만 연산 속도가 느림

```
공개키와 개인키는 서로를 위한 1쌍의 키이다.

공개키: 모두에게 공개가능한 키
개인키: 나만 가지고 알고 있어야 하는 키
```

- 공개키 vs 개인키 암호화
  - 공개키 암호화 : 개인키로만 복호화 = 나만 볼 수 있음
  - 개인키 암호화 : 공개키로만 복호화 = 모두가 볼 수 있음, 내가 인증한 정보임을 알려 신뢰성 보장 가능.

<img src="HTTP_image\암호화.png" style="zoom: 80%;" >



### HTTPS 동작 과정

HTTPS는 대칭키 암호화와 비대칭키 암호화를 모두 사용 => 안정성 + 빠른 연산 속도

HTTP 통신하는 소켓 부분을 `SSL(Secure Socket Layer)` or `TLS(Transport Layer Security)`라는 프로토콜로 대체하는 것 

```
데이터를 송신할 때,

HTTP는 애플리케이션 계층(HTTP) 에서 전송 계층(TCP)로 보내지만, HTTPS는 SSL로 전송하고 SSL은 받은 데이터를 암호화하여,전송계층(TCP)로 전달해는 방식으로 데이터를 송신한다. 

데이터를 수신할 때, HTTP는 전송 계층(TCP)에서 애플리케이션 계층(HTTP)로 보내지만, HTTPS는 전송계층(TCP)에서 SSL로 보내고, SSL은 복호화하여 애플리케이션 계층(HTTPS)로 전달하여 데이터 수신한다.

송신할 때는 HTTP는 TCP를 SSL로 인식하고, 수신할 때는 TCP가 HTTP를 SSL로 인식하게 함으로써 동작하기 때문에 
기존 전달 방식을 그대로 사용 가능
```



```
소켓?
기본적으로 소켓은 통신을 위한 일종의 통로라고 생각할 수 있습니다. 
두 프로그램이 네트워크를 통해 서로 통신을 수행할 수 있도록 양쪽에 생성되는 링크의 단자입니다.
두 소켓이 연결되면 서로 다른 프로세스끼리 데이터를 전달할 수 있습니다.
결국 소켓이 구현됨으로써 네트워크 및 전송 계층의 캡슐화가 가능해집니다. 


SSL?
SSL(Secure Sockets Layer)은 암호화 기반 인터넷 보안 프로토콜. 
인터넷 통신의 개인정보 보호, 인증, 데이터 무결성을 보장하기 위해 Netscape가 1995년 처음으로 개발. 
SSL은 현재 사용 중인 TLS 암호화의 전신입니다.

TLS?
SSL == TLS 같은 말입니다. 네스케이프에 의해서 SSL이 발명되었고, 이것이 점차 폭넓게 사용되다가 표준화 기구인 IETF의 관리로 변경되면서 TLS라는 이름으로 바뀌었다. TLS 1.0은 SSL 3.0을 계승한다. 하지만 TLS라는 이름보다 SSL이라는 이름이 훨씬 많이 사용되고 있다.
```



#### how?

> 처음 연결을 성립하여 안전하게 세션키를 공유하는 과정에서 비대칭키가 사용되는 것이고, 
> 이후에 데이터를 교환하는 과정에서 빠른 연산 속도를 위해 대칭키(세션키)가 사용되는 것이다.

1. 클라이언트(브라우저)가 서버로 최초 연결 시도를 함
2. 서버는 공개키(엄밀히는 인증서)를 브라우저에게 넘겨줌
3. 브라우저는 인증서의 유효성을 검사하고 세션키를 발급함
4. 브라우저는 세션키를 보관하며 추가로 서버의 공개키로 세션키를 암호화하여 서버로 전송함
5. 서버는 개인키로 암호화된 세션키를 복호화하여 세션키를 얻음
6. 클라이언트와 서버는 동일한 세션키를 공유하므로 데이터를 전달할 때 세션키로 암호화/복호화를 진행함



**여기서 잠깐!  [ HTTPS의 발급 과정 ] **

> 서버는 클라이언트와 세션키를 공유하기 위한 공개키를 생성해야 하는데, 
> 일반적으로는 인증된 기관(Certificate Authority)에 공개키를 전송하여 인증서를 발급 받는다.

1. A 기업은 HTTP 기반의 애플리케이션에 HTTPS를 적용하기 위해 CA 기업에게 돈을 지불하고 공개키를 저장하는 인증서 발급을 요청함.

2. CA 기업은 CA기업의 이름, 서버의 공개키, 서버의 정보 등을 기반으로 인증서를 생성하고 CA기업의 개인키로 암호화해서 제공.

3.  A기업은 클라이언트에게 암호화된 인증서를 제공함.

4. 클라이언트는 CA기업의 공개키를 미리 다운받아 가지고 있어, 암호회된 인증서를 복호화하여 A기업의 공개키로 세션키를 공유함.


​	자체적으로 인증서 발급을 할 수 있고, 신뢰할 수 없는 CA기업에서 인증서 발급을 받는 경우도 있기 때문에, HTTPS를 지원한다면 무조건 안전한 건 아닙니다. 그런 경우, '주의 요함', '안전하지 않은 사이트'라고 알림이 뜹니다.



<img src="HTTP_image\https과정.png" style="zoom: 33%;" > <img src="HTTP_image\https발급.png" style="zoom: 67%;" >



<br>

### HTTP와 HTTPS

HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면, HTTPS는 안전하게 데이터를 주고받을 수 있다.

하지만 HTTPS를 이용하면 암호화/복호화 과정이 필요하므로 HTTP보다 속도가 느리다.(그러나 오늘날에는 거의 차이를 못 느낄 정도.)

또한, HTTPS는 인증서를 발급하고 유지하기 위한 추가 비용이 발생한다.

> **그렇다면 언제 HTTP를 쓰고, 언제 HTTPS를 쓰는 것이 좋겠는가?**
> 개인 정보와 같은 민감한 데이터를 주고 받아야 한다면 HTTPS를 이용해야 하지만, 
> 노출이 되어도 괜찮은 단순한 정보 조회 등 만을 처리하고 있다면 HTTP를 이용하면 된다.

하지만 최근에는 하드웨어의 발달로 인해 HTTPS를 사용하더라도 속도 저하가 거의 일어나지 않으며, 

새로운 표준인 HTTP 2.0을 함께 이용한다면 오히려 HTTPS가 HTTP보다 더 빠르게 동작한다. 

따라서 웹은 과거의 민감한 정보를 다룰 때만 HTTPS에 의한 암호화 통신을 사용하는 방식에서 

**현재 모든 웹 페이지에서 HTTPS를 적용하는 방향으로 바뀌어가고 있다.**

<br>

<hr>

### 예상질문



**Q. http와 https 통신 방식의 차이에 대해 설명해주세요.**

HTTP는 Hyper Text Transfer Protocol의 약자로, **서버/클라이언트 간 데이터를 주고받을 때 쓰는 통신 규약**으로, WWW(월드와이드웹)상에서 웹페이지나 이미지 같은 정보를 요청과 응답에 의해 주고받는 프로토콜입니다. 평문으로 통신하기 때문에 개인 정보 노출 등의 보안상 문제가 있습니다. 이를 해결하기 위한 것이 https입니다. 

HTTPS는 HTTP 메시지(텍스트)를 암호화하는 것이며, S는 **Secure Socket**, **통신 보안망**을 말하며, **공개키 암호화 방식**을 거칩니다.

<br>

**Q. 공개키 암호화 방식이 뭐죠?**

공개키 암호화 방식은 사전에 비밀키를 나눠가지지 않은 사용자들이 안전하게 통신할 수 있도록 설계된 것입니다. 암/복호화에 다른 암호통신을 위해 공개키와 개인키 2개의 키를 사용합니다. 

//++ 구체적 방법은 위에 참고++//

<br>

 **Q.  무상태와 비연결성에 대해 설명해주세요.**

**무상태성**은 연결을 끊는 순간 클라이언트와 서버의 통신이 종료되며 **상태 정보는 유지하지 않는 특성**이 있으며, 비연결성은 요청과 응답이 끝나면 세션이 끊기는 것을 말합니다. 서버 입장에선 통신 연결을 유지하지 않아 **리소스 낭비가 줄어드는 장점**이 있지만, 통신마다 **새로운 세션**을 열어야 하는 작업은 클라이언트가 서버에게 **요청 시마다 인증해야 하는** 단점이 있습니다.

//+++추가내용+++//

이런 단점을 극복하기 위해서 **HTTP1.1에서 Keep-Alive기능**을 제공하여 한 번에 여러 요청-응답이 가능해졌다. 

KeepAlive는 지정된 시간동안 서버와 클라이언트 사이에서 패킷 교환이 없을 경우, 상대방의 안부를 묻기위해 패킷을 주기적으로 보내는것을 말합니다. 이 때, 패킷에 반응이 없으면 접속을 끊게 됩니다. 하지만 이또한 주기적으로 클라이언트 상태를 체크한다는 점에서 완벽한 해결책은 아닙니다.

<br>

<hr>
#### 참고자료

출처: https://mangkyu.tistory.com/98 [MangKyu's Diary:티스토리]

출처: https://mindnet.tistory.com/entry/네트워크-쉽게-이해하기-9편-프로토콜-이란-Protocol-이란-무엇인가 [Mind Net:티스토리]

출처:https://victorydntmd.tistory.com/286