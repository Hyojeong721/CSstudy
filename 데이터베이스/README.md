## 데이터베이스 CS study 정리

# 01 데이터베이스 

### 데이터베이스 관리 시스템 (DBMS, DataBaseManagementSystem)

데이터베이스 관리 시스템이란 `다수의 사용자들`이 데이터베이스 내의 `데이터를 접근할 수 있도록 해주는 소프트웨어들`을 의미한다. 데이터베이스 관리 시스템이 존재하기 이전에는 파일 시스템을 이용하여 데이터를 관리하였다. 파일 시스템은 응용 프로그램을 이용해 데이터를 파일로 관리하는 것이다. 예를 들어, 쇼핑몰의 경우 고객 관리 프로그램과 주문 관리 프로그램이 존재하여 각각 데이터를 파일로 저장해 관리한다. 파일을 기반으로 데이터를 관리하게 되면 데이터 중복, 데이터 불일치 등 문제가 발생한다. 이러한 파일 시스템의 단점을 보완하기 위해 데이터베이스가 생겨났다. `데이터베이스`는 곧 `데이터베이스 관리 시스템`이라 할만큼 데이터베이스 관리 시스템은 중요하다고 볼 수 있다. 데이터베이스 관리 시스템을 전문적으로 운영하는 인력을 DBA (DataBase Administrator)라 한다.

```
데이터 불일치 문제란?
데이터 불일치 문제는 데이터를 파일로 저장했을 때 파일을 수정하는 도중에 해당 파일을 불러온다면 데이터가 동기화 문제가 발생하여 데이터가 불일치하는 문제가 발생할 수 있다.
```

#### 데이터베이스의 특징

1. 데이터의 `독립성`( 파일 시스템은 데이터와 응용 프로그램이 상호 의존 관계에 있다. )

   - 물리적 독립성 : 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다.

     (파일 시스템은 응용 프로그램의 기능을 확장하려면 파일의 구조를 재조직해야 한다.)

   - 논리적 독립성 : 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다. ( 파일 시스템에서는 파일의 구조가 응용 프로그램에 반영되어 있기 때문에 파일의 구조가 바뀌면 영향을 받는 모든 응용 프로그램들을 수정해야 한다. )

2. 데이터의 `무결성` 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.

   ( 파일 시스템은 응용 프로그램 별로 제약 조건을 하나하나 처리해야하기 때문에 무결성을 유지하기가 어렵다. )

3. 데이터의 `보안성` 인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다.

   ( 파일 시스템은 파일 단위로 검색, 갱신, 실행 등의 권한을 부여할 수 있어서 사용자 별 세밀한 접근 제어가 어렵다.)

4. 데이터의 `일관성` 연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다. ( 파일 시스템에서는 중복된 데이터를 변경하는 게 어렵기 때문에 중복 데이터 중 일부만 변경된다고 하면 중복 데이터 간에 불일치가 발생할 수 있다. )

5. 데이터 `중복 최소화` 데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.

   ( 파일 시스템은 응용 프로그램별로 데이터를 파일로 관리하기 때문에 같은 데이터가 여러 파일에 저장되어 데이터 중복 문제가 발생할 수 있다. )

#### 데이터베이스의 장단점

- ##### 데이터베이스 장점

1. 데이터 중복 최소화
2. 데이터 공유
3. 일관성, 무결성, 보안성 유지
4. 최신의 데이터 유지
5. 데이터의 표준화 가능
6. 데이터의 논리적, 물리적 독립성
7. 용이한 데이터 접근
8. 데이터 저장 공간 절약

- ##### 데이터베이스 단점

1. 데이터베이스 전문가 필요
2. 많은 비용 부담
3. 데이터 백업과 복구가 어려움
4. 시스템의 복잡함
5. 대용량 디스크로 엑세스가 집중되면 과부하 발생



### 데이터베이스 모델

#### 계층형 데이터 모델

[![img](https://github.com/Hyojeong721/CSstudy/raw/main/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/%EA%B3%84%EC%B8%B5%ED%98%95.png)](https://github.com/Hyojeong721/CSstudy/blob/main/데이터베이스/데이터베이스/계층형.png)

- 트리 형태의 수직적인 데이터 모델이다.

- 1:N의 대응 관계만 존재한다.

- 상위 레코드 삭제시 연쇄 삭제(Triggered Delete)가 일어난다.

- 개체들 간에는 Cycle이 허용되지 않는다.

- 관계형 모델에서의 Entity를 계층형에선 Segment라 부른다.

  ```
  데이터베이스 엔티티(DataBase Entity)란?
  
  사전적 의미의 엔티티(Entity) : 실체, 실재, 객체
  데이터베이스에서 한 건의 자료를 구성하는 레코드를 말한다. 엔티티 사이의 관계를 릴레이션(relationship)이라 하고, 이것을 도표로 나타낸 것을 ERD(Entity Relationship Diagram)라고 한다.
  ```

- 파일 시스템을 생각하면 이해하기 쉽다. 폴더 안에 하위 폴더 안에 파일이 있는 그런 형태이다. 여러 하위 폴더가 한 상위폴더에 있을 수는 있지만 한 하위폴더가 여러 상위폴더에 위치할 순 없다.

- 대표적인 DBMS는 IBM의 IMS가 있다.

#### 네트워크형 데이터 모델

[![img](https://github.com/Hyojeong721/CSstudy/raw/main/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%ED%98%95.png)](https://github.com/Hyojeong721/CSstudy/blob/main/데이터베이스/데이터베이스/네트워크형.png)

- 계층형의 단점을 좀 더 보완한 데이터 모델이다.
- 상하위 레코드 사이에서 N:N구조를 허용한다.
- CODASYL이란 회사에서 DBTG라는 데이터베이스를 출시하며 제안한 모델로, CODASYL DBTG모델이라고 불리기도 한다.
- 정확한 비유는 아니지만, 바로가기(링크)가 자유롭게 사용되는 파일 시스템을 떠올리면 어떤 계층형에 비해 어떤 보완이 이루어졌는지 이해하기 쉽다. 하위에서 상위로의 이동이 자유로우며 여러 상위 계층으로의 이동도 자유로운 것이다.
- 여기선 상하위 관계를 Owner, Member라고 표현한다.
- 대표적인 DBMS는 DBTG, EDBS, TOTAL등이 있다.

#### 관계형 데이터 모델

[![img](https://github.com/Hyojeong721/CSstudy/raw/main/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/%EA%B4%80%EA%B3%84%ED%98%95.png)](https://github.com/Hyojeong721/CSstudy/blob/main/데이터베이스/데이터베이스/관계형.png)

- 계층형, 네트워크형의 단점을 보완한 현재 가장 이상적인 모델이다.
- 우리가 흔히 보는 Table(표)들로 구성되고 표의 칼럼간 관계가 정의되는 구조의 DB가 관계형 데이터모델이다.
- 대표적인 DBMS로 오라클, MySQL, SQLite등 우리가 아는 거의 모든 데이터 베이스들이 여기 속한다.
- 거의 표준에 가까우므로 DBMS간 변환이 용이하다.
- 단점으론, 보는 우리는 편한데 구현이 쉽진 않다. 많은 연산에 대해 계층형이나 네트워크형보다 퍼포먼스가 떨어지는 경우가 많다.

### 데이터베이스의 성능

#### 성능 개선 절차

데이터베이스 성능 튜닝 방법론은 튜닝 작업에 필요한 여러 가지 수행 방법과 이러한 작업들을 효율적으로 수행하려는 과정에서 필요한 각각의 단계들을 체계적으로 정리하여 표준화한 것으로써 분석, 이행, 평가 3단계를 거쳐 성능 최적화의 목적을 달성하기 위한 단계별 접근 전략이다.

##### 1. 분석

튜닝 분석 단계에서는 자료 수집과 목표 설정이라는 2단계로 나뉜다.

###### 자료 수집

데이터베이스 모니터링과 데이터베이스 객체 현황 파악 및 물리 설계 요소에 대해 성능과 관련된 지표들을 분석하기 위한 기초 자료를 수집하는 단계이다.

###### 목표 설정

수집된 기초 자료를 통해 데이터 모델 분석, 액세스 패스 분석, 시스템 자원 현황 분석, SQL 성능 분석, SQL 효율 분석 등을 종합하여 성능상에 병목이나 지연 등과 같은 문제 요소 등을 구체적으로 파악하고 성능 튜닝의 대상이 되는 목표들을 구체화하여 방향을 설정하는 단계이다.

##### 2. 이행

튜닝 이행 단계에서는 성능상의 문제 요소로 파악된 대상에 대해 최적화 방안을 수립하고 적용하는 단계이다.

- 데이터베이스 파라미터(Parameter) 조정
- 전략적인 저장 기법 적용을 위한 물리 설계 및 디자인 검토
- 비효율적으로 수행되는 SQL 문에 대한 최적화
- 네트워크 부하 등을 고려한 데이터베이스 분산 구조에 대한 최적화
- 적절한 인덱스 구성 및 사용을 위한 인덱스 설계 등의 최적화 작업

##### 3. 평가

튜닝 평가 단계에서는 분석 단계에서 진단을 통해 분류된 문제 요소들에 대해 설정된 개선 목표와 이행단계에서 구체적인 튜닝 작업을 수행한 후의 성과를 비교 측정하는 단계이다. 튜닝 목표와 튜닝성과에 차이가 있다면 그 요소들을 파악한 후 목표와 성과를 합치시키는 과정을 거친다.



------

**왜 굳이 DB 로 관리하기 시작했을까?**

그 이유는 파일 단위로 저장할때, 데이터 종속성 문제와 중복성, 데이터 무결성 문제가 존재하기 때문이다.

**데이터베이스의 특징**

1. 데이터 독립성
2. 데이터 무결성
3. 데이터의 보안성
4. 데이터의 일관성
5. 데이터 중복 최소화

**데이터베이스 모델 종류**

관계형 / 네트워크형 / 계층형

------

출처: https://raisonde.tistory.com/entry/시험대비-데이터베이스-모델의-종류와-특징을-쉽게-이해하자 [지식잡식:티스토리]

출처: https://noahlogs.tistory.com/36 [인생의 로그캣:티스토리]

# 02 인덱스 

## 인덱스 Index

### 정의

[![img](https://camo.githubusercontent.com/b877db9f47d65884cbc9200e4bbe7efdc8f79a770eac8619387a01cbe3a7cd0d/68747470733a2f2f626c6f672e6b616b616f63646e2e6e65742f646e2f6351693852502f62747138426b52725266622f613543306a483570665341324b4b7a3743396642376b2f696d672e706e67)](https://camo.githubusercontent.com/b877db9f47d65884cbc9200e4bbe7efdc8f79a770eac8619387a01cbe3a7cd0d/68747470733a2f2f626c6f672e6b616b616f63646e2e6e65742f646e2f6351693852502f62747138426b52725266622f613543306a483570665341324b4b7a3743396642376b2f696d672e706e67)

> 인덱스는 말 그대로 책의 맨 처음 또는 맨 마지막에 있는 ***색인***이라고 할 수 있다.
>
> DBMS 도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져 오려면 시간이 오래 걸린다. 그래서 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두는 것이다.
>
> DBMS 의 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데는 빠르지만 새로운 값을 **추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다**. 결론적으로 DBMS 에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다.
>
> SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다.

장점

1. 조건 검색 Where 절의 효율성
2. 정렬 Ordery By 절의 효율성
3. MIN, MAX 의 효율적인 처리

단점

1. 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.

2. 정렬된 상태를 계속 유지해야 하기 때문에, 관리를 위한 추가작업이 필요하다.

3. CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있다.

4. 컬럼을 이루고 있는 데이터의 형식에 따라서 인덱스의 성능이 악영향을 미칠 수 있다

   `이름`, `나이`, `성별` 세 가지의 필드를 갖고 있는 테이블을 생각해보자. 이름은 온갖 경우의 수가 존재할 것이며 나이는 INT 타입을 갖을 것이고, 성별은 남, 녀 두 가지 경우에 대해서만 데이터가 존재할 것임을 쉽게 예측할 수 있다. 이 경우 어떤 컬럼에 대해서 인덱스를 생성하는 것이 효율적일까? 결론부터 말하자면 이름에 대해서만 인덱스를 생성하면 효율적이다.

   왜 성별이나 나이는 인덱스를 생성하면 비효율적일까? 10000 레코드에 해당하는 테이블에 대해서 2000 단위로 성별에 인덱스를 생성했다고 가정하자. 값의 range 가 적은 성별은 인덱스를 읽고 다시 한 번 디스크 I/O 가 발생하기 때문에 그 만큼 비효율적인 것이다.

### 자료구조

#### B+ Tree 인덱스 알고리즘

[![image-20220630201433186](https://github.com/Hyojeong721/CSstudy/raw/main/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/index.assets/image-20220630201433186.png)](https://github.com/Hyojeong721/CSstudy/blob/main/데이터베이스/index.assets/image-20220630201433186.png)

DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다.

- 리프노드(데이터노드)만 인덱스와 함께 데이터(Value)를 가지고 있고, 나머지 노드(인덱스노드)들은 데이터를 위한 인덱스(Key)만을 갖는다.
- 리프노드들은 LinkedList로 연결되어 있다.
- 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다.

그 외 장점

1. leaf node를 제외하고 데이터를 저장하지 않기 때문에 메모리를 더 확보할 수 있다. 따라서 하나의 node에 더 많은 포인터를 가질 수 있기 때문에 트리의 높이가 더 낮아지므로 검색 속도를 높일 수 있다.
2. Full scan을 하는 경우 B+Tree는 leaf node에만 데이터가 저장되어 있고, leaf node끼리 linked list로 연결되어 있기 때문에 선형 시간이 소모된다. 반면 B-Tree는 모든 node를 확인해야 한다.

#### Hash 인덱스 알고리즘

칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다.

하지만

1. 해시가 등호(=) 연산에만 특화되었기 때문에, 해시 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하므로, 부등호 연산이 자주 사용되는 데이터베이스 검색에서는 적합하지 않다.
2. 값을 변형해서 인덱싱하므로, 특정 문자로 시작하는 값으로 검색을 하는 전방 일치와 같이 값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다.

주로 메모리 기반의 데이터베이스에서 많이 사용한다.

### B+ Tree vs Hash

데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있다. 이러한 이유로 B-Tree의 리프노드들을 LinkedList로 연결하여 순차검색을 용이하게 하는 등 B-Tree를 인덱스에 맞게 최적화하였다.

### etc

#### Composite Index (결합 인덱스)

- 여러 컬럼을 모아 하나의 인덱스로 만드는 방식. 주로 SQL 문장에서 WHERE 절의 조건 컬럼이 2개 이상의 AND 로 연결되어 함께 사용되는 경우에 많이 사용된다.
- 단, OR로 조회되는 경우는 결합 인덱스를 만들면 안된다.
- 특징
  - 인덱스의 첫 번째 컬럼이 조건절에 없다면 일반적으로 인덱스가 사용되지 않는다.
  - Equal 연산이 아닌 검색 조건이 들어오는 경우(범위 연산), 처리 범위가 크게 증가하여 효율이 크게 저하될 수 있다.
  - 

#### `clustered index` vs `non-clustered index`

Clustered Index가 단일 포인터라면 Non-Clustered Index는 이중 포인터인 셈입니다.

[![img](https://camo.githubusercontent.com/f98cae049f61705dcb2a334a30b2115b274070970d26e6f435af4dba61604742/68747470733a2f2f76656c6f672e76656c63646e2e636f6d2f696d6167657325324667696c6c6f67253246706f737425324661653337633565342d313035302d343561312d386336302d3862323238616137636263372532463939333331393437354331374244324430312e6a7067)](https://camo.githubusercontent.com/f98cae049f61705dcb2a334a30b2115b274070970d26e6f435af4dba61604742/68747470733a2f2f76656c6f672e76656c63646e2e636f6d2f696d6167657325324667696c6c6f67253246706f737425324661653337633565342d313035302d343561312d386336302d3862323238616137636263372532463939333331393437354331374244324430312e6a7067)

#### `primary key` & `secondary key`

특정 데이터를 찾기 위해서는 Secondrary Key에서 PK를 찾고, 그 PK를 통해 다시 원하는 데이터로 찾아가는 형태

[![img](https://camo.githubusercontent.com/795c5bf37b6e02ea1e4d3f17f8a9a3fd87bfbd8e6b20099ba3b6c09c9428b188/687474703a2f2f322e62702e626c6f6773706f742e636f6d2f2d7154376858595f584655382f564c6a692d494777494f492f4141414141414141414f452f496736425034304a6172342f73313630302f696d616765323031342d31322d323225324231312d35302d34352e706e67)](https://camo.githubusercontent.com/795c5bf37b6e02ea1e4d3f17f8a9a3fd87bfbd8e6b20099ba3b6c09c9428b188/687474703a2f2f322e62702e626c6f6773706f742e636f6d2f2d7154376858595f584655382f564c6a692d494777494f492f4141414141414141414f452f496736425034304a6172342f73313630302f696d616765323031342d31322d323225324231312d35302d34352e706e67)

# 03 정규화

관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업이다. 좀 더 구체적으로는 불만족스러운 **나쁜** **릴레이션**의 애트리뷰트들을 나누어서 **좋은** 작은 릴레이션으로 분해하는 작업을 말한다. 정규화 과정을 거치게 되면 정규형을 만족하게 된다. 정규형이란 특정 조건을 만족하는 릴레이션의 스키마의 형태를 말하며 제 1 정규형, 제 2 정규형, 제 3 정규형, … 등이 존재한다.

##### 나쁜' 릴레이션은 어떻게 파악하는가?

엔티티를 구성하고 있는 애트리뷰트 간에 **함수적 종속성**(Functional Dependency)을 판단한다. 판단된 함수적 종속성은 좋은 릴레이션 설계의 정형적 기준으로 사용된다. 즉, 각각의 정규형마다 어떠한 함수적 종속성을 만족하는지에 따라 정규형이 정의되고, 그 정규형을 만족하지 못하는 정규형을 나쁜 릴레이션으로 파악한다.

##### 함수적 종속성이란 무엇인가?

함수적 종속성이란 애트리뷰트 데이터들의 의미와 애트리뷰트들 간의 상호 관계로부터 유도되는 제약조건의 일종이다. X 와 Y 를 임의의 애트리뷰트 집합이라고 할 때, X 의 값이 Y 의 값을 유일하게(unique) 결정한다면 "X 는 Y 를 함수적으로 결정한다"라고 한다. 함수적 종속성은 실세계에서 존재하는 애트리뷰트들 사이의 제약조건으로부터 유도된다. 또한 각종 추론 규칙에 따라서 애트리뷰트들간의 함수적 종속성을 판단할 수 있다. *cf> 애트리뷰트들의 관계로부터 추론된 함수적 종속성들을 기반으로 추론 가능한 모든 함수적 종속성들의 집합을 폐포라고 한다.*

##### 각각의 정규형은 어떠한 조건을 만족해야 하는가?

1. 분해의 대상인 분해 집합 D 는 **무손실 조인** 을 보장해야 한다.
2. 분해 집합 D 는 함수적 종속성을 보존해야 한다.

##### 정규화(Normalization)의 기본 목표는 테이블 간에 중복된 데이타를 허용하지 않는다는 것이다. 중복된 데이터를 허용하지 않음으로써 무결성(Integrity)를 유지할 수 있으며, DB의 저장 용량 역시 줄일 수 있다. 또 정규화가 진행되어있지 않은 경우 `갱신이상`이 발생할 수 있다.

#### 갱신 이상에는 어떠한 것들이 있는가?

- 삽입 이상(insertion anomalies) 원하지 않는 자료가 삽입된다든지, 삽입하는데 자료가 부족해 삽입이 되지 않아 발생하는 문제점을 말한다.
- 삭제 이상(deletion anomalies) 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 문제점을 말한다.
- 수정(갱신)이상(modification anomalies) 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어져 정확한 정보 파악이 되지 않는 문제점을 말한다.

#### 제 1정규화

제1 정규화란 테이블의 컬럼이 원자값(Atomic Value, 하나의 값)을 갖도록 테이블을 분해하는 것이다. 예를 들어 아래와 같은 고객 취미 테이블이 존재한다고 하자.

[![1정규화(전)]()](https://github.com/Hyojeong721/CSstudy/blob/main/데이터베이스/정규화.md)

위의 테이블에서 추신수와 박세리는 여러 개의 취미를 가지고 있기 때문에 제1 정규형을 만족하지 못하고 있다. 그렇기 때문에 이를 제1 정규화하여 분해할 수 있다. 제1 정규화를 진행한 테이블은 아래와 같다.

[![1정규화(후)]()](https://github.com/Hyojeong721/CSstudy/blob/main/데이터베이스/정규화.md)

#### 제2 정규화

제2 정규화란 제1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것이다. 여기서 완전 함수 종속이라는 것은 기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미한다. 예를 들어 아래와 같은 수강 강좌 테이블을 살펴보자.

[![2정규화(전)]()](https://github.com/Hyojeong721/CSstudy/blob/main/데이터베이스/정규화.md)

이 테이블에서 기본키는 (학생번호, 강좌이름)으로 복합키이다. 그리고 (학생번호, 강좌이름)인 기본키는 성적을 결정하고 있다. (학생번호, 강좌이름) --> (성적) 그런데 여기서 강의실이라는 컬럼은 기본키의 부분집합인 강좌이름에 의해 결정될 수 있다. (강좌이름) --> (강의실) 즉, 기본키(학생번호, 강좌이름)의 부분키인 강좌이름이 결정자이기 때문에 위의 테이블의 경우 다음과 같이 기존의 테이블에서 강의실을 분해하여 별도의 테이블로 관리하여 제2 정규형을 만족시킬 수 있다.

[![2정규화(후)]()](https://github.com/Hyojeong721/CSstudy/blob/main/데이터베이스/정규화.md)

#### 제3 정규화

제3 정규화란 제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것이다. 여기서 이행적 종속이라는 것은 A -> B, B -> C가 성립할 때 A -> C가 성립되는 것을 의미한다. 예를 들어 아래와 같은 계절 학기 테이블을 살펴보자.

[![3정규화(전)]()](https://github.com/Hyojeong721/CSstudy/blob/main/데이터베이스/정규화.md)

기존의 테이블에서 학생 번호는 강좌 이름을 결정하고 있고, 강좌 이름은 수강료를 결정하고 있다. 그렇기 때문에 이를 (학생 번호, 강좌 이름) 테이블과 (강좌 이름, 수강료) 테이블로 분해해야 한다. 이행적 종속을 제거하는 이유는 비교적 간단하다. 예를 들어 501번 학생이 수강하는 강좌가 스포츠경영학으로 변경되었다고 하자. 이행적 종속이 존재한다면 501번의 학생은 스포츠경영학이라는 수업을 20000원이라는 수강료로 듣게 된다. 물론 강좌 이름에 맞게 수강료를 다시 변경할 수 있지만, 이러한 번거로움을 해결하기 위해 제3 정규화를 하는 것이다. 즉, 학생 번호를 통해 강좌 이름을 참조하고, 강좌 이름으로 수강료를 참조하도록 테이블을 분해해야 하며 그 결과는 다음의 그림과 같다.

[![3정규화(후)]()](https://github.com/Hyojeong721/CSstudy/blob/main/데이터베이스/정규화.md)

#### BCNF 정규화

BCNF 정규화란 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것이다. 예를 들어 다음과 같은 특강수강 테이블이 존재한다고 하자.

[![BCNF정규화(전)]()](https://github.com/Hyojeong721/CSstudy/blob/main/데이터베이스/정규화.md)

특강수강 테이블에서 기본키는 (학생번호, 특강이름)이다. 그리고 기본키 (학생번호, 특강이름)는 교수를 결정하고 있다. 또한 여기서 교수는 특강이름을 결정하고 있다. 그런데 문제는 교수가 특강이름을 결정하는 결정자이지만, 후보키가 아니라는 점이다. 그렇기 때문에 BCNF 정규화를 만족시키기 위해서 위의 테이블을 분해해야 하는데, 다음과 같이 특강신청 테이블과 특강교수 테이블로 분해할 수 있다.

[![BCNF정규화(후)]()](https://github.com/Hyojeong721/CSstudy/blob/main/데이터베이스/정규화.md)

*각 정규형은 그의 선행 정규형보다 더 엄격한 조건을 갖는다.*

- 모든 제 2 정규형 릴레이션은 제 1 정규형을 갖는다.
- 모든 제 3 정규형 릴레이션은 제 2 정규형을 갖는다.
- 모든 BCNF 정규형 릴레이션은 제 3 정규형을 갖는다.

수많은 정규형이 있지만 관계 데이터베이스 설계의 목표는 각 릴레이션이 3NF(or BCNF)를 갖게 하는 것이다.

### 정규화의 단점

릴레이션의 분해로 인해 릴레이션 간의 연산(**JOIN 연산**)이 많아진다. 이로 인해 질의에 대한 응답 시간이 느려질 수 있다. 조금 덧붙이자면, 정규화를 수행한다는 것은 데이터를 결정하는 결정자에 의해 함수적 종속을 가지고 있는 일반 속성을 의존자로 하여 입력/수정/삭제 이상을 제거하는 것이다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다. 따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있는 특성이 있다.

### 단점에 대한 대응책은?

조회를 하는 SQL 문장에서 조인이 많이 발생하여 이로 인한 성능저하가 나타나는 경우에 **반정규화**를 적용하는 전략이 필요하다.

#### 반정규화(De-normalization, 비정규화)

`반정규화`는 정규화된 엔티티, 속성, 관계를 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 중복 통합, 분리 등을 수행하는 데이터 모델링 기법 중 하나이다. 디스크 I/O 량이 많아서 조회 시 성능이 저하되거나, 테이블끼리의 경로가 너무 멀어 조인으로 인한 성능 저하가 예상되거나, 칼럼을 계산하여 조회할 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다. 일반적으로 조회에 대한 처리 성능이 중요하다고 판단될 때 부분적으로 반정규화를 고려하게 된다.

[![반정규화]()](https://github.com/Hyojeong721/CSstudy/blob/main/데이터베이스/정규화.md)

##### 무엇이 반정규화의 대상이 되는가?

1. 자주 사용되는 테이블에 액세스하는 프로세스의 수가 가장 많고, 항상 일정한 범위만을 조회하는 경우
2. 테이블에 대량 데이터가 있고 대량의 범위를 자주 처리하는 경우, 성능 상 이슈가 있을 경우
3. 테이블에 지나치게 조인을 많이 사용하게 되어 데이터를 조회하는 것이 기술적으로 어려울 경우

##### 반정규화 과정에서 주의할 점은?

반정규화를 과도하게 적용하다 보면 데이터의 무결성이 깨질 수 있다. 또한 입력, 수정, 삭제의 질의문에 대한 응답 시간이 늦어질 수 있다.

참고자료 : https://mangkyu.tistory.com/110, https://rebro.kr/160

# 04 트랜잭션 Transaction

- 데이터베이스 상태를 일관적으로 유지하기 위한 병행 수행 제어 및 회복의 기본 단위
- 한꺼번에 모두 수행되어야 할 일련의 데이터베이스의 논리적 집합
- 작업의 단위는 사람이 정한다.

예) 게시판에 글을 등록하려고 한다. 글을 작성하고, 게시하고, 다시 게시판으로 돌아온다고 한다.

작성한 글을 데이터에 올릴때 Insert, 게시판 목록으로 나가서 게시판의 글들을 가져올 때 select 작업이 이루어진다. 이 때 insert + select 가 하나의 트랜잭션 단위.

## 특성 (ACID)

### 1. 원자성 Atomicity

- 분해가 불가능한 작업의 최소 단위

- 연산 전체가 성공 또는 실패 (**All or Nothing**)

  → 하나의 트랜잭션은 Commit 되거나 Rollback 된다.

- 하나라도 실패할 경우 전체가 취소되어야 함

- 주요기법

  - Commit: 하나의 트랜잭션이 성공적으로 끝나고, 데이터베이스가 일관성 있는 상태에 있거나 하나의 트랜잭션이 끝났을 때 사용하는 연산.
  - Rollback: 하나의 트랜잭션이 비정상적으로 종료되어 트랜잭션 원자성이 깨질 경우 처음부터 다시 시작하거나, 부분적으로 연산을 취소하는 연산.

### 2. 일관성 Consistency

- 트랜잭션 실행 성공 후 항상 **일관된 데이터베이스 상태**를 보존해야 함
- 주요기법
  - 무결성 제약조건
    - 무결성이란: 데이터의 정확성, 일관성. 즉, 데이터에 결함이 없는 상태.
    - 무결성을 보장하기 위해 저장, 삭제, 수정 등을 제약하기 위한 조건
  - 병행제어: 다수 사용자 환경에서 여러 트랜잭션을 수행할 때, 데이터베이스 일관성 유지를 위해 상호작용을 제어하는 기법

### 3. 독립성 Isolation

- 트랜잭션 실행 중 생성하는 연산의 중간 결과를 다른 트랜잭션이 접근 불가
- 주요기법
  - Read Uncommitted: commit이나 rollback 여부에 상관없이 다른 트랜잭션에서 보여짐
  - Read Committed: commit이 완료된 데이터만 다른 트랜잭션에서 보여짐
  - Repeatable Read: 하나의 트랜잭션 내에서 동일 select 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다는 정합성 정의
  - Serializable: 선행 트랜잭션이 특정 데이터 영역을 순차적으로 읽을 때, 해당 데이터 영역 전체에 대한 접근을 제한하는 수준
  - 더 자세히 알고싶다면,,,, [[MySQL\] isolation level 종류 및 특징 :: Louis.Kim 의 제 3막 (tistory.com)](https://hyunki1019.tistory.com/111)

### 4. 지속성 Durability

- 성공이 완료된 트랜잭션의 결과는 영구적으로 데이터베이스에 저장
- 주요기법
  - 회복기법: 트랜잭션을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 이전의 정상적인 상태로 복구시키는 작업

## 상태변화

[![image](https://github.com/Hyojeong721/CSstudy/raw/main/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/assets/transaction.png)](https://github.com/Hyojeong721/CSstudy/blob/main/데이터베이스/assets/transaction.png)

- 활성 (Active)
  - 초기상태, 트랜잭션이 실행중일 때 가지는 상태
- 부분 완료 (Partially Committed)
  - 마지막 명령문이 실행된 후에 가지는 상태 (commit 직전)
- 완료 (Commited)
  - 트랜잭션이 성공적으로 완료된 후 가지는 상태
- 실패 (Failed)
  - 정상적인 실행이 더 이상 진행될 수 없을 때 가지는 상태
- 철회 (Aborted)
  - 트랜잭션이 취소되고 데이터베이스가 트랜잭션 시작 전 상태로 환원된 상태

# 05 교착상태

#### 교착상태란 무엇인가

복수의 **트랜잭션**을 사용하다보면 교착상태가 일어날수 있다. 교착상태란 두 개 이상의 트랜잭션이 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태가 되는데, 이를 `교착상태`라고 한다.

##### 트랜잭션

- 데이터베이스 상태를 일관적으로 유지하기 위한 병행 수행 제어 및 회복의 기본 단위
- 한꺼번에 모두 수행되어야 할 일련의 데이터베이스의 논리적 집합
- 작업의 단위는 사람이 정한다.

#### 교착상태의 예(MySQL)

MySQL [MVCC](https://en.wikipedia.org/wiki/Multiversion_concurrency_control)에 따른 특성 때문에 트랜잭션에서 갱신 연산(Insert, Update, Delete)를 실행하면 잠금을 획득한다. (기본은 행에 대한 잠금)

[![classic deadlock 출처: https://darkiri.wordpress.com/tag/sql-server/](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/raw/master/Database/images/deadlock.png)](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/blob/master/Database/images/deadlock.png)

트랜잭션 1이 테이블 B의 첫번째 행의 잠금을 얻고 트랜잭션 2도 테이블 A의 첫번째 행의 잠금을 얻었다고 하자.

```
Transaction 1> create table B (i1 int not null primary key) engine = innodb;
Transaction 2> create table A (i1 int not null primary key) engine = innodb;

Transaction 1> start transaction; insert into B values(1);
Transaction 2> start transaction; insert into A values(1);
```

트랜잭션을 commit 하지 않은채 서로의 첫번째 행에 대한 잠금을 요청하면

```
Transaction 1> insert into A values(1);
Transaction 2> insert into B values(1);
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
```

Deadlock 이 발생한다. 일반적인 DBMS는 교착상태를 독자적으로 검출해 보고한다.

## 교착 상태 해결방법

### 예방 기법

각 트랜잭션이 실행되기전에 필요한 데이터를 모두 잠금(Locking)하는 것. 하지만 데이터가 많이 필요할 경우 모든 데이터를 잠금해야 되기 때문에 트랜잭션의 병행성을 보장하지 못한다. 뿐만 아니라 몇몇 트랜잭션들은 계속해서 처리를 못하게 되는 기아 상태가 발생할 수 있다.

### 회피 기법

위의 단점 때문에 실제로 교착상태를 해결하기 위한 방법으로 회피 기법이 많이 사용된다. 회피 기법은 자원을 할당할 때 시간 스탬프(Time Stamp)를 사용하여 교착상태가 일어나지 않도록 회피하는 방법으로 Wait-Die 방식과 Wound-Wait 방식이 있다.

#### Wait-Die 방식

다른 트랜잭션이 데이터를 점유하고 있을 때 기다리거나(Wait) 포기(Die)하는 방식으로 선행 트랜잭션이 접근하면 대기(wait), 후행 트랜잭션이 접근하면 포기(die)한다. 즉, 오래된 프로세스에게 대기의 기회를 제공하고, 최신 프로세스는 자주 복귀함으로써 오버헤드의 가능성이 있다.

[![img](https://camo.githubusercontent.com/4ebd9dceb6f3c8719d015763ac4dd2c9e3f06487eb196840f884fe698cc2ae21/68747470733a2f2f7061726b6d75687965756e2e6769746875622e696f2f6173736574732f2f696d672f626c6f672f6574632f64617461626173652f646c5f312e504e47)](https://camo.githubusercontent.com/4ebd9dceb6f3c8719d015763ac4dd2c9e3f06487eb196840f884fe698cc2ae21/68747470733a2f2f7061726b6d75687965756e2e6769746875622e696f2f6173736574732f2f696d672f626c6f672f6574632f64617461626173652f646c5f312e504e47)

#### Wound-Wait 방식

다른 트랜잭션이 데이터를 점유하고 있을 때 빼앗거나(Wound) 기다리는(Wait) 방식으로 선행 트랜잭션이 접근하면 선점(wound), 후행 트랜잭션이 접근하면 대기(wait)한다. 즉, 오래된 프로세스에게 선점의 기회를 제공하고 최신 프로세스는 대기함에 따라 복귀를 최소화한다.

[![img](https://camo.githubusercontent.com/3ee40c8a1e947df763f4a2adefaf331297af1ce028b10384d302625f30522c75/68747470733a2f2f7061726b6d75687965756e2e6769746875622e696f2f6173736574732f2f696d672f626c6f672f6574632f64617461626173652f646c5f322e504e47)](https://camo.githubusercontent.com/3ee40c8a1e947df763f4a2adefaf331297af1ce028b10384d302625f30522c75/68747470733a2f2f7061726b6d75687965756e2e6769746875622e696f2f6173736574732f2f696d672f626c6f672f6574632f64617461626173652f646c5f322e504e47)

### 낙관적 병행 기법

낙관적 병행 기법은 트랜잭션이 실행되는 동안에는 아무런 검사를 하지 않고, 트랜잭션이 다 실행된 이후에 검사 후 문제가 있다면 되돌리는 방법

### 빈도 낮추기

교착 상태의 빈도를 낮추는 방법으로는

- 트랜잭션을 자주 커밋
- 트랜잭션들이 동일한 테이블 순으로 접근하게 한다.
- 읽기 잠금 획득( 사용법 : SELECT ~ FOR UPDATE )의 사용을 피한다. (SELECT시에도 트랜잭션의 잠금을 갖는것을 피한다.)
- 테이블 단위의 잠금을 획득해 갱신을 직렬화

# 06 Statement VS PreparedStatement

*Statement* 와 *PreparedStatement* 모두 SQL 쿼리를 실행하는 데 사용한다.

**PreparedStatement 와 Statement의 가장 큰 차이점**은 캐시(cache) 사용여부이다.

1. 쿼리 문장 분석
2. 컴파일
3. 실행

Statement를 사용하면 매번 쿼리를 수행할 때마다 1) ~ 3) 단계를 거치게 되고,

PreparedStatement는 처음 한 번만 세 단계를 거친 후 캐시에 담아 재사용을 한다는 것이다.

만약 동일한 쿼리를 반복적으로 수행한다면 PreparedStatment가 DB에 훨씬 적은 부하를 주며, 성능도 좋다.

------

#### Statement

DB를 연결하기 위한 일반적인 목적으로 사용된다.

고정적인 쿼리를 실행할때 유용하며 매개변수를 받을 수 없다.

SQL문이 달라지더라도 한개만 생성해서 재사용이 가능하다.

```
Statement stmt = conn.createStatement(); // 생성
stmt.execute(sql); //실행
```

#### PreparedStatement

쿼리를 자주 사용할 때 이용된다.

실행시간에 매개변수를 받을 수 있다.

Statement에 비해 반복적인 SQL문을 사용할 경우 더 빠르다.

DB컬럼타입과 관계없이 하나로 표시하면 되기 때문에 개발자가 혼동하지 않고 사용가능하며

SQL문마다 PreparedStatement객체를 각각 생성해야 하기 때문에 재사용이 불가능하다.

```
PreparedStatement pstmt = conn.prepareStatement(sql); // 생성
pstmt.execute(); // 실행
```

------

##### Statement를 반드시 사용해야 하는 경우

1. Dynamic SQL을 사용할 경우

Dynamic SQL을 사용한다면 매번 조건절이 달라지기 때문에 Statement가 더 낫다! + 코딩도 훨씬 편함.

##### 참고 ( Static SQL / Dynamic SQL )

`Static SQL`이란, String형 변수(값)를 담지않고 코드 사이에 직접 기술한 SQL문을 말한다. 다른 말로 'Embedded SQL',

아래 예시처럼 SQL문을 String 변수에 담지 않고 마치 예약된 키워드처럼 C/C++코드 사이에 섞어서 기술하고 있다. Static SQL이든 Dynamic SQL이든 PreCompile 단계를 거치고 나면 String 변수에 담기기는 마찬가지지만 Static SQL은 런타임시에 절대 변하지 않으므로 PreCompile 단계에서 구문 분석, 유효 오브젝트 여부, 오브젝트 액세스 권한 등을 체크하는 것이 가능하다.

```
Init main()
\{
	Printf("사번입력하셈:");
	Scanf("%d", &empno);
	EXEC SQL WHENEVER NOT FOUND GOTO notfound;
	EXEC SQL SELECT ENAME INTO : ename
				FROM EMP
				WHERE EMPNO = :	empno;
  	Printf("사원명 : %s.\n", name);
Notfound:
	Printf("%d는 존재하지 않는 사번입니다.\n", empno);
\}
```

`Dynamic SQL`이란 String형 변수에 담아서 기술하는 SQL문을 말한다. String 변수를 사용하므로 조건에 따라 SQL문을 동적으로 바꿀 수 있고, 런타임 시에 사용자로부터 SQL문의 일부 또는 전부를 입력받아서 실행할 수도 있다. 따라서 preCompile 시 systax, semantics 체크가 불가능하다.

------

출처: https://devbox.tistory.com/entry/Comporison [장인개발자를 꿈꾸는 :: 기록하는 공간:티스토리]

출처 : https://blog.daum.net/ipajama/133 [Static SQL / Dynamic SQL ]

## 2. JDBC API 인터페이스

*Statement* 와 *PreparedStatement* 모두 SQL 쿼리를 실행하는 데 사용할 수 있습니다. 이러한 인터페이스는 매우 유사해 보입니다. 그러나 기능 및 성능면에서 서로 크게 다릅니다.

- *명령문* – **문자열 기반 SQL** **쿼리 를 실행하는 데 사용됩니다.**
- *PreparedStatement* – **매개변수화된 SQL 쿼리를 실행하는 데 사용됩니다.**

예제에서 *Statement* 및 *PreparedStatement* 를 사용할 수 있도록 *pom.xml* 파일 에서 *h2* JDBC 커넥터를 종속성으로 선언 합니다.

```
<dependency>
  <groupId>com.h2database</groupId>
  <artifactId>h2</artifactId>
  <version>1.4.200</version>
</dependency>
```

이 문서 전체에서 사용할 엔터티를 정의해 보겠습니다.

```
public class PersonEntity {
    private int id;
    private String name;

    // standard setters and getters
}
```

## 3. Statement

첫째, *Statement* 인터페이스 는 문자열을 SQL 쿼리로 받아들입니다. 따라서 SQL 문자열 을 연결할 때 **코드 가독성이 떨어집니다 .**

```
public void insert(PersonEntity personEntity) {
    String query = "INSERT INTO persons(id, name) VALUES(" + personEntity.getId() + ", '"
      + personEntity.getName() + "')";

    Statement statement = connection.createStatement();
    statement.executeUpdate(query);
}
```

둘째, **[SQL 인젝션](https://www.baeldung.com/cs/sql-injection)** **에 취약하다** . 다음 예는 이러한 약점을 보여줍니다.

첫 번째 줄에서 업데이트는 모든 행의 " *name " 열을 "* *hacker* "로 설정합니다. "—" 이후의 모든 항목은 SQL에서 주석으로 해석되고 업데이트 문의 조건은 무시됩니다. *두 번째 줄에서 " name* " 열의 따옴표가 이스케이프 처리되지 않았기 때문에 삽입이 실패합니다 .

```
dao.update(new PersonEntity(1, "hacker' --"));
dao.insert(new PersonEntity(1, "O'Brien"))
```

셋째, **JDBC는 인라인 값이 있는 쿼리를 데이터베이스에 전달합니다** . 따라서 쿼리 최적화가 없으며 가장 중요한 것은 **데이터베이스 엔진이 모든 검사를 보장해야 한다는 것** 입니다. 또한 쿼리는 데이터베이스에 동일하게 표시되지 않으며 **캐시 사용을 방지합니다** . 마찬가지로 일괄 업데이트는 별도로 실행해야 합니다.

```
public void insert(List<PersonEntity> personEntities) {
    for (PersonEntity personEntity: personEntities) {
        insert(personEntity);
    }
}
```

넷째, **Statement** ***인터페이스\* 는 CREATE , ALTER 및 DROP 과 같은 DDL 쿼리 에 적합합니다** .

```
public void createTables() {
    String query = "create table if not exists PERSONS (ID INT, NAME VARCHAR(45))";
    connection.createStatement().executeUpdate(query);
}
```

마지막으로 **Statement** ***인터페이스\*** **는 파일과 배열을 저장하고 검색하는 데 사용할 수 없습니다** .

## 4. *PreparedStatement*

첫째, *PreparedStatement* *는 Statement* 인터페이스를 확장합니다 . 파일 및 배열을 포함하여 **다양한 개체 유형을 바인딩하는 메서드가 있습니다.** 따라서 **코드** **를 이해하기 쉬워** 집니다 .

```
public void insert(PersonEntity personEntity) {
    String query = "INSERT INTO persons(id, name) VALUES( ?, ?)";

    PreparedStatement preparedStatement = connection.prepareStatement(query);
    preparedStatement.setInt(1, personEntity.getId());
    preparedStatement.setString(2, personEntity.getName());
    preparedStatement.executeUpdate();
}
```

둘째, 제공된 모든 매개변수 값에 대한 텍스트를 이스케이프 처리하여 **SQL 주입으로부터 보호합니다 .**

```
@Test 
void whenInsertAPersonWithQuoteInText_thenItNeverThrowsAnException() {
    assertDoesNotThrow(() -> dao.insert(new PersonEntity(1, "O'Brien")));
}

@Test 
void whenAHackerUpdateAPerson_thenItUpdatesTheTargetedPerson() throws SQLException {

    dao.insert(Arrays.asList(new PersonEntity(1, "john"), new PersonEntity(2, "skeet")));
    dao.update(new PersonEntity(1, "hacker' --"));

    List<PersonEntity> result = dao.getAll();
    assertEquals(Arrays.asList(
      new PersonEntity(1, "hacker' --"), 
      new PersonEntity(2, "skeet")), result);
}
```

셋째, ***PreparedStatement\*** **는 사전 컴파일을 사용** 합니다. 데이터베이스는 쿼리를 받자마자 쿼리를 미리 컴파일하기 전에 캐시를 확인합니다. 따라서 **캐시되지 않은 경우 데이터베이스 엔진은 다음 사용을 위해 이를 저장합니다.**

또한 이 기능 은 SQL이 아닌 바이너리 프로토콜을 통해 **데이터베이스와 JVM 간의 통신 속도를 높 입니다.** 즉, 패킷에 데이터가 적으므로 서버 간의 통신이 더 빨라집니다.

넷째, ***PreparedStatement\*** **는 단일 데이터베이스 연결 동안 [일괄](https://www.baeldung.com/jdbc-batch-processing)** 실행을 제공합니다 . 이것을 실제로 봅시다:

```
public void insert(List<PersonEntity> personEntities) throws SQLException {
    String query = "INSERT INTO persons(id, name) VALUES( ?, ?)";
    PreparedStatement preparedStatement = connection.prepareStatement(query);
    for (PersonEntity personEntity: personEntities) {
        preparedStatement.setInt(1, personEntity.getId());
        preparedStatement.setString(2, personEntity.getName());
        preparedStatement.addBatch();
    }
    preparedStatement.executeBatch();
}
```

다음으로, ***PreparedStatement\*** ***는 BLOB\*** **및** ***CLOB\*** **데이터 유형** **을 사용하여 파일을 저장하고 검색하는 쉬운 방법을 제공합니다** . 같은 맥락에서 *java.sql.Array* 를 SQL Array로 변환하여 목록을 저장하는 데 도움이 됩니다.

마지막으로 *PreparedStatement* 는 반환된 결과에 대한 정보를 포함하는 *getMetadata()* 와 같은 메서드를 구현합니다 .

## 5. 결론

*이 자습서에서는 PreparedStatement* 와 *Statement* 의 주요 차이점을 제시했습니다 . 두 인터페이스 모두 SQL 쿼리를 실행하는 메서드를 제공하지만 DDL 쿼리 에는 *Statement 를 사용하고 DML 쿼리에는* *PreparedStatement* 를 사용하는 것이 더 적합 합니다.

------

출처 : https://www.baeldung.com/java-statement-preparedstatement

# 07 NoSQL

### 정의

> (1)
>
> - 관계형 데이터 모델을 ***지양*** 하며
> - 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며
> - 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소를 말한다.
>
> (2)
>
> - 특정 데이터 모델에 대해 특정 목적에 맞추어 구축되는 데이터베이스로서 현대적인 애플리케이션 구축을 위한 유연한 스키마를 갖추고 있습니다.
>
> (3)
>
> - NoSQL 데이터베이스(일명 "SQL만을 사용하지 않는 데이터베이스")는 표 형식이 아니며, 관계형 테이블과는 다른 방식으로 데이터를 저장합니다. NoSQL 데이터베이스는 데이터 모델에 따라 유형이 다양합니다. 주요 유형으로는 문서, 키 값, 와이드 컬럼, 그래프가 있습니다. 이들은 유연한 스키마를 제공하며, 대량의 데이터와 높은 사용자 부하에서도 손쉽게 확장이 가능합니다.

### 특징

#### CAP 이론

[![Diagram of CAP Theorem](https://camo.githubusercontent.com/99078f28786081b695424bfa94e6fb799d679aa09330104f777b3b7272c6c610/687474703a2f2f65696e63732e636f6d2f696d616765732f323031332f30362f74727574682d6f662d6361702d7468656f72656d2d6469616772616d2e706e67)](https://camo.githubusercontent.com/99078f28786081b695424bfa94e6fb799d679aa09330104f777b3b7272c6c610/687474703a2f2f65696e63732e636f6d2f696d616765732f323031332f30362f74727574682d6f662d6361702d7468656f72656d2d6469616772616d2e706e67)

분산형 구조는 아래 3가지 특징을 가지고 있으며, CAP 이론은 이 중 2가지만 만족할 수 있다는 이론이다.

NoSQL 은 대부분 CAP 이론을 따른다.

1. 일관성(Consistency) :
   - 분산된 노드 중 어느 노드로 접근하더라도 데이터 값이 같아야 한다.
2. 가용성(Availability)
   - 클러스터링된 노드 중 하나 이상의 노드가 실패(Fail)라도 정상적으로 요청을 처리할 수 있는 기능을 제공한다.
3. 네트워크 분할 허용성(Partition tolerance)
   - 클러스터링 노드 간에 통신하는 네트워크가 장애가 나더라도 정상적으로 서비스를 수행한다. 노드 간 물리적으로 전혀 다른 네트워크공간에 위치도 가능하다.

### 유형

1. Key-Value Model
   - 가장 기본적인 형태의 NoSQL 이며 키 하나로 데이터 하나를 저장하고 조회할 수 있는 단일 키-값 구조를 갖는다.
   - 단순한 저장구조로 인하여 복잡한 조회 연산을 지원하지 않는다. 또한 고속 읽기와 쓰기에 최적화된 경우가 많다.
   - 캐싱, 사용자의 프로필 정보, 웹 서버 클러스터를 위한 세션 정보, 장바구니 정보, URL 단축 정보 저장 등에 사용한다
   - DynamoDB, Redis
2. Document Model
   - 키-값 모델을 개념적으로 확장한 구조로 하나의 키에 하나의 구조화된 문서를 저장하고 조회
     - JSON(JavaScript Object Notation) 객체와 비슷한 문서에 데이터를 저장
     - 일반적으로 값은 문자열, 숫자, 불리언(boolean), 어레이, 객체 등 유형이 다양할 수 있으며, 구조는 개발자가 코드에서 사용하고 있는 객체에 맞춰 조정
   - 개발자들이 자신의 애플리케이션 코드에서 사용하는 것과 동일한 문서 모델 형식을 사용하여, 손쉽게 데이터를 저장하고 쿼리 가능
   - 유연하고 반구조화된 계층적 특성을 통해 개발자는 계속해서 애플리케이션의 요구를 발전 가능
   - 중앙 집중식 로그 저장, 타임라인 저장, 통계 정보 저장 등에 사용
   - MongoDB
3. Column Model
   - 하나의 키에 여러 개의 컬럼 이름과 컬럼 값의 쌍으로 이루어진 데이터를 저장하고 조회한다. 모든 컬럼은 항상 타임 스탬프 값과 함께 저장된다.
     - 각 행이 동일한 열을 가질 필요가 없다는 점에서 관계형 데이터베이스에 대해 뛰어난 유연성을 제공
   - 대부분의 컬럼 모델 NoSQL 은 쓰기와 읽기 중에 쓰기에 더 특화되어 있다.
     - 데이터를 먼저 커밋로그와 메모리에 저장한 후 응답하기 때문에 빠른 응답속도를 제공한다. 그렇기 때문에 읽기 연산 대비 쓰기 연산이 많은 서비스나 빠른 시간 안에 대량의 데이터를 입력하고 조회하는 서비스를 구현할 때 가장 좋은 성능을 보인다.
     - 채팅 내용 저장, 실시간 분석을 위한 데이터 저장소 등의 서비스 구현에 적합하다.
   - Cassandra, HBase
4. Graph Model
   - 노드와 엣지에 데이터를 저장
     - 노드에는 일반적으로 사람, 장소 및 사물에 대한 정보가 저장되고, 에지에는 노드 간의 관계에 대한 정보가 저장
   - 소셜 네트워크, 추천 엔진, 사기 탐지, 같은 패턴을 찾아보기 위해 관계를 상세히 검토해야 하는 사용 사례에 적합
   - Neo4j, JanusGraph

## etc

### CAP 이론?

[CAP Theorem, 오해와 진실](http://eincs.com/2013/07/misleading-and-truth-of-cap-theorem/)

### NoSQL 배경

[NoSQL 이란](https://www.mongodb.com/ko-kr/nosql-explained)

> NoSQL 데이터베이스는 2000년대 말에 스토리지 비용이 크게 하락하면서 등장했습니다. 단순히 데이터 중복 감소를 목적으로 복잡하고 관리가 어려운 데이터 모델을 생성해야 하던 시절은 이제 지났습니다. 스토리지가 아니라 개발자들이 소프트웨어 개발의 1차 비용이 되었기 때문에 NoSQL 데이터베이스는 ***개발자 생산성에 맞게 최적화***되었습니다.
>
> 저장 및 쿼리를 위해 필요한 데이터 애플리케이션의 양도 증가했습니다. 이러한 데이터는 정형, 반정형, 다형적 등 모양과 크기가 모두 다르기 때문에 미리 스키마를 정의하는 것이 거의 불가능해졌습니다. NoSQL 데이터베이스는 개발자가 ***엄청난 양의 비정형 데이터를 저장할 수 있도록 지원하여 뛰어난 유연성을 제공***합니다.
>
> 뿐만 아니라, [Agile Manifesto](https://agilemanifesto.org/)의 인기가 높아지면서 소프트웨어 개발자들은 소프트웨어 개발 방식을 재고하기 시작했습니다. 그리고 변화하는 요구사항에 발 빠르게 적응해야 할 필요가 있음을 인식했습니다. 이들에게는 데이터베이스 모델에 이르기까지 소프트웨어 스택 전반에서 반복 작업과 변경을 신속하게 수행할 수 있는 능력이 필요했습니다. NoSQL 데이터베이스는 개발자들에게 이러한 유연성을 제공했습니다.
>
> 클라우드 컴퓨팅 역시 인기가 높아졌고, 개발자들은 퍼블릭 클라우드를 사용해 애플리케이션과 데이터를 호스팅하기 시작했습니다. 이들은 여러 서버와 리전에 데이터를 분산시켜 애플리케이션 복원력을 높이고, 스케일업이 아닌 스케일아웃을 수행하며, 데이터를 지능적으로 배치할 수 있기를 원했습니다. MongoDB 같은 일부 NoSQL 데이터베이스들은 이러한 기능을 제공하고 있습니다.